diff -Naur psyno/src/common.d psyno-gentoo/src/common.d
--- psyno/src/common.d	2004-11-13 19:13:12.000000000 +0100
+++ psyno-gentoo/src/common.d	2007-09-23 12:07:31.000000000 +0200
@@ -1,4 +1,3 @@
-import mymath;
-import myio;
-import log;
-import std.math;
+public import mymath;
+public import myio;
+public import std.math;
diff -Naur psyno/src/enemy.d psyno-gentoo/src/enemy.d
--- psyno/src/enemy.d	2004-12-01 13:46:54.000000000 +0100
+++ psyno-gentoo/src/enemy.d	2007-09-24 18:45:32.000000000 +0200
@@ -50,7 +50,7 @@
         else { 
             static const int CO_STACK_SIZE = (16 * 1024);
        }
-        coro_ = co_create(&enemy_spawn, this, null, CO_STACK_SIZE);
+        coro_ = co_create(&enemy_spawn,  cast(void*)this, null, CO_STACK_SIZE);
 
         move_.init(this);
     }
diff -Naur psyno/src/game.d psyno-gentoo/src/game.d
--- psyno/src/game.d	2004-12-02 00:40:10.000000000 +0100
+++ psyno-gentoo/src/game.d	2007-09-23 12:45:43.000000000 +0200
@@ -37,6 +37,7 @@
     static Game obj() {
         return obj_;
     }
+    PatternMgr patternmgr;
 
 public:
     this(char[] replayFile) {
@@ -166,8 +167,9 @@
 
         std.gc.fullCollect();
 //        std.gc.disable();
+        patternmgr = new PatternMgr;
 
-        PatternMgr.init();
+        patternmgr.init();
 
         Particle.init();
 
@@ -221,13 +223,13 @@
         addPatternWait_--;
         if (addPatternWait_ < 0 && patterns_.length < 5 &&
             player_.comboCnt() == 0) {
-            if (!PatternMgr.addNextPattern() && enemyMgr_.objNum == 0) {
+            if (!patternmgr.addNextPattern() && enemyMgr_.objNum == 0) {
                 isEnd_ = true;
             }
         }
 /*
         if (enemyMgr_.objNum() < 5 || rnd(300) == 0) {
-            PatternMgr.addRandomPattern();
+            patternmgr.addRandomPattern();
         }
 */
 /*
diff -Naur psyno/src/glbf.d psyno-gentoo/src/glbf.d
--- psyno/src/glbf.d	2004-11-13 19:13:12.000000000 +0100
+++ psyno-gentoo/src/glbf.d	2007-09-23 12:16:07.000000000 +0200
@@ -8,7 +8,7 @@
 import std.math;
 import std.c.stdio;
 import std.c.stdlib;
-import std.string;
+import std.c.string;
 import opengl;
 import openglu;
 import SDL;
diff -Naur psyno/src/http.d psyno-gentoo/src/http.d
--- psyno/src/http.d	2004-11-28 08:45:53.000000000 +0100
+++ psyno-gentoo/src/http.d	2007-09-23 12:13:47.000000000 +0200
@@ -324,7 +324,7 @@
         return res;
     }
 
-    bool alive() { return ss_ !== null; }
+    bool alive() { return ss_ !is null; }
 
     bool close() { return close; }
     void close(bool c) { close_ = c; }
diff -Naur psyno/src/http_thread.d psyno-gentoo/src/http_thread.d
--- psyno/src/http_thread.d	2004-11-30 15:12:14.000000000 +0100
+++ psyno-gentoo/src/http_thread.d	2007-09-23 12:16:40.000000000 +0200
@@ -24,8 +24,8 @@
             isEnd_ = true;
         }
         catch (Object o) {
-            Log.warn("cannot connect score server: " ~ o.toString());
-            isError_ = true;
+//            Log.warn("cannot connect score server: " ~ o.toString());
+  //          isError_ = true;
         }
 
         return 0;
diff -Naur psyno/src/log.d psyno-gentoo/src/log.d
--- psyno/src/log.d	2004-11-26 21:37:20.000000000 +0100
+++ psyno-gentoo/src/log.d	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-private import std.stream;
-private import std.string;
-private import std.c.stdlib;
-
-private import SDL;
-
-class Log {
-    static void init() {
-        version (Win32) {
-            s = new File("out.txt", FileMode.OutNew);
-        }
-        else {
-            s = stdout;
-        }
-    }
-    static void quit() {
-        version (Win32) {
-            s.close();
-        }
-        s = null;
-    }
-    static Stream s;
-
-    static bit errored = false;
-    static void report(char[] tag, char[] msg) {
-        s.writeLine("[" ~ tag ~ "] " ~ msg);
-    }
-    static void error(char[] msg) {
-        report("ERROR", msg);
-        errored = true;
-        assert(false);
-    }
-    static void errorSDL(char[] msg) {
-        error("[SDL] " ~ msg ~ ": " ~ std.string.toString(SDL_GetError()));
-    }
-    static void warn(char[] msg) {
-        report("WARN", msg);
-    }
-    static void warnSDL(char[] msg) {
-        warn("[SDL] " ~ msg ~ ": " ~ std.string.toString(SDL_GetError()));
-    }
-    static void info(char[] msg) {
-        report("INFO", msg);
-    }
-    static void dbg(char[] msg) {
-        debug {
-            report("DBG", msg);
-        }
-    }
-    static void dbg(int msg) {
-        debug {
-            report("DBG", std.string.toString(msg));
-        }
-    }
-    static bit isErrored() {
-        return errored;
-    }
-
-}
diff -Naur psyno/src/Makefile psyno-gentoo/src/Makefile
--- psyno/src/Makefile	2004-12-03 03:47:48.000000000 +0100
+++ psyno-gentoo/src/Makefile	2007-09-25 20:57:48.000000000 +0200
@@ -1,21 +1,21 @@
-BUILDTYPE=Release
-#BUILDTYPE=Debug
+#BUILDTYPE=Release
+BUILDTYPE=Debug
 
-DC=dmd
-#DC=gdc
-EXE=sino
+#DC=dmd
+DC=gdc
+EXE=../psyno
 
 include Makefile.init
 
-CFLAGS += `sdl-config --cflags`
+
 
 INCLUDES += -Isdl -Iopengl 
-LIBS += `sdl-config --libs` -lpthread -lm -lSDL_pad -lGL -lGLU -lSDL_mixer pcl-1.3/pcl/pcl.o -lSDL_pad -lSDL_net
+LIBS += `sdl-config --libs` -lpthread -lm -lGL -lGLU -lSDL_mixer pcl-1.3/pcl/pcl.o SDL_pad/.libs/libSDL_pad.a -lSDL_net
 ifeq ($(DC), dmd)
 DFLAGS += -op
-LIBS += -lphobos
+LIBS += -lgphobos
 else
-LIBS += /usr/local/stow/gcc-gdc-3.4.0/lib/libphobos.a
+LIBS += -lgphobos
 endif
 
 SDLSOURCES=sdl/SDL_joystick.d sdl/SDL_video.d sdl/SDL_pad.d sdl/SDL_mixer.d sdl/SDL_net.d
@@ -30,7 +30,7 @@
 #	ruby gen_iointer.rb
 
 $(SDLOBJS): %.o:%.d
-	$(DC) $(OUT) -c $(DFLAGS) $(INCLUDES) $<
+	$(DC) $(OUT) -c $(DFLAGS) $(INCLUDES) $< && mv SDL*.o ./sdl
 
 pcl-1.3/Makefile:
 	cd pcl-1.3; ./configure
diff -Naur psyno/src/Makefile.init psyno-gentoo/src/Makefile.init
--- psyno/src/Makefile.init	2004-09-01 15:36:00.000000000 +0200
+++ psyno-gentoo/src/Makefile.init	2007-09-21 19:14:50.000000000 +0200
@@ -45,16 +45,16 @@
 endif
 
 ifeq ($(BUILDTYPE), Release)
-	GCCFLAGS+=-O2 -W -Wall -DNDEBUG -ffast-math -fomit-frame-pointer -D$(PLATFORM)
+	GCCFLAGS+=-O2 -W -DNDEBUG -ffast-math -fomit-frame-pointer -D$(PLATFORM)
 	DMDFLAGS+=-O -release
-	GDCFLAGS+=-frelease
+	GDCFLAGS+=-d -frelease
 endif
 
 ifeq ($(BUILDTYPE), Debug)
-	GCCFLAGS+=-g -W -Wall -D$(PLATFORM)
+	GCCFLAGS+=-g -W  -D$(PLATFORM)
 	DMDFLAGS+=-g -debug
 	DMDFLAGS+=-unittest
-	GDCFLAGS+=-fdebug
+	GDCFLAGS+=-fdebug -ffast-math -fdeprecated
 endif
 
 CFLAGS+=$(GCCFLAGS)
diff -Naur psyno/src/myglbf.d psyno-gentoo/src/myglbf.d
--- psyno/src/myglbf.d	2004-11-13 19:13:12.000000000 +0100
+++ psyno-gentoo/src/myglbf.d	2007-09-23 12:17:02.000000000 +0200
@@ -9,9 +9,9 @@
 void initLetter() {
     int ret = glbfInit(&font, `data/kochi.bmp`, 12, 14, 21);
     if (ret != 0) {
-        Log.errorSDL("failed initialize font");
+ //       Log.errorSDL("failed initialize font");
     }
-    Log.info("initialize font");
+ //   Log.info("initialize font");
 }
 
 void drawNum(int num, float x, float y, float sx, float sy,
diff -Naur psyno/src/mygl.d psyno-gentoo/src/mygl.d
--- psyno/src/mygl.d	2004-11-13 19:13:12.000000000 +0100
+++ psyno-gentoo/src/mygl.d	2007-09-23 12:14:34.000000000 +0200
@@ -1,5 +1,5 @@
-import opengl;
-import openglu;
+public import opengl;
+public import openglu;
 private import game;
 
 void myglCircle(float x, float y, float r, float[] xs, float[] ys) {
@@ -96,7 +96,7 @@
     glVertex3f(x2, y2, z2);
 }
 
-// 3, 4 引数のみ clip
+// 3, 4 clip
 void myglClippedLine2(float x1, float y1, float x2, float y2) {
     myglClippedLine2(x1, y1, x2, y2, 0);
 }
diff -Naur psyno/src/mymath.d psyno-gentoo/src/mymath.d
--- psyno/src/mymath.d	2004-11-13 19:13:12.000000000 +0100
+++ psyno-gentoo/src/mymath.d	2007-09-23 12:15:21.000000000 +0200
@@ -49,7 +49,7 @@
     return x*x+y*y;
 }
 
-float length(float x, float y) {
+float lengthy(float x, float y) {
     return std.math.sqrt(length2(x, y));
 }
 
@@ -84,7 +84,7 @@
 }
 
 void normalize(inout float x, inout float y) {
-    float d = length(x, y);
+    float d = lengthy(x, y);
     x /= d;
     y /= d;
 }
diff -Naur psyno/src/opengl/opengl.d psyno-gentoo/src/opengl/opengl.d
--- psyno/src/opengl/opengl.d	2004-12-01 13:48:15.000000000 +0100
+++ psyno-gentoo/src/opengl/opengl.d	2007-09-21 16:04:18.000000000 +0200
@@ -1,10 +1,5 @@
-version (Win32) {
-	private import std.c.windows.windows;
-	extern(Windows):
-}
-else {
 	extern(C):
-}
+
 
 alias uint GLenum;
 alias ubyte GLboolean;
@@ -1116,7 +1111,7 @@
 /*************************************************************/
 
 void /*APIENTRY*/glAccum (GLenum op, GLfloat value);
-void /*APIENTRY*/glAlphaFunc (GLenum func, GLclampf ref);
+void /*APIENTRY*/glAlphaFunc (GLenum func, GLclampf);
 GLboolean /*APIENTRY*/glAreTexturesResident (GLsizei n, GLuint *textures, GLboolean *residences);
 void /*APIENTRY*/glArrayElement (GLint i);
 void /*APIENTRY*/glBegin (GLenum mode);
@@ -1369,7 +1364,7 @@
 void /*APIENTRY*/glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
 void /*APIENTRY*/glSelectBuffer (GLsizei size, GLuint *buffer);
 void /*APIENTRY*/glShadeModel (GLenum mode);
-void /*APIENTRY*/glStencilFunc (GLenum func, GLint ref, GLuint mask);
+void /*APIENTRY*/glStencilFunc (GLenum func, GLint, GLuint mask);
 void /*APIENTRY*/glStencilMask (GLuint mask);
 void /*APIENTRY*/glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
 void /*APIENTRY*/glTexCoord1d (GLdouble s);
diff -Naur psyno/src/opengl/openglu.d psyno-gentoo/src/opengl/openglu.d
--- psyno/src/opengl/openglu.d	2004-12-01 13:48:21.000000000 +0100
+++ psyno-gentoo/src/opengl/openglu.d	2007-09-21 16:04:23.000000000 +0200
@@ -1,11 +1,6 @@
 import opengl;
 
-version (Win32) {
-	extern(Windows):
-}
-else {
 	extern(C):
-}
 
 GLubyte* gluErrorString (
     GLenum   errCode);
diff -Naur psyno/src/pattern.d psyno-gentoo/src/pattern.d
--- psyno/src/pattern.d	2004-12-02 12:00:05.000000000 +0100
+++ psyno-gentoo/src/pattern.d	2007-09-23 12:17:20.000000000 +0200
@@ -6,7 +6,7 @@
 private import pversion;
 
 class PatternMgr {
-    static void init() {
+    void init() {
         patterns_.length = 0;
         patternIte_ = 0;
         patternLevel_ = 0;
diff -Naur psyno/src/player.d psyno-gentoo/src/player.d
--- psyno/src/player.d	2004-12-02 03:01:53.000000000 +0100
+++ psyno-gentoo/src/player.d	2007-09-23 12:18:00.000000000 +0200
@@ -3,7 +3,7 @@
 
 private import common;
 private import sino;
-private import log;
+private import SDL_pad;
 private import charactor;
 private import shot;
 private import sound;
@@ -80,7 +80,7 @@
         if (isQdInvisible()) {
             static float prevAngle = float.nan;
 
-            if (nearest_ === null ||
+            if (nearest_ is null ||
                 (prevAngle != a_ && state_ == State.ATACKED)) {
                 prevAngle = a_;
 
@@ -150,7 +150,7 @@
         }
 
         void atackCommon() {
-            if (nearest_ === null) return;
+            if (nearest_ is null) return;
 
             float d2 = distance2(x_, y_, nearest_.x, nearest_.y);
             float a = angle(x_, y_, nearest_.x, nearest_.y);
@@ -172,7 +172,7 @@
                     foreach (Shot s; Game.obj.shots()) {
                         if (!s.alive()) continue;
 
-                        // @@@ コピペでコードを書くな
+                        //
                         if (distance2(nearest_.x, nearest_.y,
                                       s.x, s.y) < 10000) {
                             s.die();
@@ -234,9 +234,9 @@
                     comboScore_ += fscore;
                     Game.obj.addScore(fscore);
 
-                    Log.info("score: " ~ tostr(score) ~ "*" ~ tostr(comboCnt_)
-                             ~ " = " ~ tostr(fscore)
-                             ~ " (vanished: " ~ tostr(vanishShotCnt_) ~ ")" );
+//                    Log.info("score: " ~ tostr(score) ~ "*" ~ tostr(comboCnt_)
+  //                           ~ " = " ~ tostr(fscore)
+    //                         ~ " (vanished: " ~ tostr(vanishShotCnt_) ~ ")" );
                 }
 
                 Game.obj.setMoveWait(14);
@@ -289,7 +289,7 @@
 
         case State.SQD:
         case State.QD:
-            if (nearest_ === null) {
+            if (nearest_ is null) {
                 state_ = State.FREE;
                 break;
             }
@@ -422,14 +422,14 @@
 
         if (!isnan(a_)) lastAngle_ = a_;
 
-        // めんどうだし当り判定もここでやっちまえ
+        // 
         if (isDamage()) {
         }
         else if (isQdInvisible()) {
             foreach (Shot s; Game.obj.shots()) {
                 if (distance2(x_, y_, s.x, s.y) < size_*size_) {
                     s.die();
-                    /* イラネ
+                    /*
                     float rs() { return rnd(20.0)-10.0; }
                     float[3] col;
                     setRndColor(col);
@@ -580,7 +580,7 @@
         glColor4f(1, 0, 0, 0.5);
 
         foreach (Enemy e; Game.obj.enemies()) {
-            if (e === nearest_) {
+            if (e is nearest_) {
                 static const int PERIOD = 4;
                 int r = turn_ % (PERIOD*3);
                 if (r < PERIOD) {
@@ -674,7 +674,7 @@
 
     float lastAngle_;
 
-    // 汎用用途の停止カウンタ
+    //
     int holdCnt_;
     int swordCnt_;
     int damageDashCnt_;
diff -Naur psyno/src/pversion.d psyno-gentoo/src/pversion.d
--- psyno/src/pversion.d	2004-12-02 02:43:13.000000000 +0100
+++ psyno-gentoo/src/pversion.d	2007-09-23 12:18:24.000000000 +0200
@@ -24,7 +24,7 @@
         initVersion(toInt(ver[0]), toInt(ver[1]), toInt(ver[2]));
     }
     else {
-        Log.warn(`corrupt replay version!, trying current version...`);
+    //    Log.warn(`corrupt replay version!, trying current version...`);
         initVersion();
     }
 }
diff -Naur psyno/src/rc.d psyno-gentoo/src/rc.d
--- psyno/src/rc.d	2004-12-07 00:40:20.000000000 +0100
+++ psyno-gentoo/src/rc.d	2007-09-23 12:20:03.000000000 +0200
@@ -1,7 +1,7 @@
 private import std.conv;
 private import std.stream;
 private import std.string;
-private import log;
+private import std.stdio;
 private import myio;
 
 extern(C) void exit(int status);
@@ -23,7 +23,7 @@
             input = new File(file);
         }
         catch (Error e) {
-            Log.error(e.toString());
+//            Log.error(e.toString());
         }
 
         while (!input.eof()) {
@@ -31,7 +31,7 @@
             if (line.length == 0 || line[0] == '#') continue;
             char[][] tok = split(line);
             if (tok.length < 1) {
-                Log.warn(file ~  ": resource file broken. (" ~ line ~ ")");
+         //       Log.warn(file ~  ": resource file broken. (" ~ line ~ ")");
                 continue;
             }
 
@@ -52,29 +52,29 @@
             }
             else {
                 if (args[i] != "-h") {
-                    dout.writeLine(args[i] ~ ": invalid option");
+                    writefln(args[i] ~ ": invalid option");
                 }
-                dout.writeLine("usage: " ~ args[0] ~ " [options]");
-                dout.writeLine("options:");
-                dout.writeLine("  -w    \tnowait");
-                dout.writeLine("  -m    \tnosound (yet)");
-                dout.writeLine("  -l    \tlow resolution (yet)");
-                dout.writeLine("  -b    \tno background (yet)");
-                dout.writeLine("  -w    \twindow (yet)");
-                dout.writeLine("  -h    \thelp");
+                writefln("usage: " ~ args[0] ~ " [options]");
+                writefln("options:");
+                writefln("  -w    \tnowait");
+                writefln("  -m    \tnosound (yet)");
+                writefln("  -l    \tlow resolution (yet)");
+                writefln("  -b    \tno background (yet)");
+                writefln("  -w    \twindow (yet)");
+                writefln("  -h    \thelp");
                 exit(1);
-            } 
+            }
         }
     }
 
 public:
     bool hasKey(char[] key) {
-        return (key in rc_) !== null;
+        return (key in rc_) !is null;
     }
 
     char[] get(char[] key) {
         if (!(key in rc_)) {
-            Log.warn(key ~ " is not in resource");
+//            Log.warn(key ~ " is not in resource");
             return "";
         }
         return rc_[key];
diff -Naur psyno/src/replaydb.d psyno-gentoo/src/replaydb.d
--- psyno/src/replaydb.d	2004-12-02 00:52:28.000000000 +0100
+++ psyno-gentoo/src/replaydb.d	1970-01-01 01:00:00.000000000 +0100
@@ -1,279 +0,0 @@
-private import common;
-private import scene_select;
-
-private import std.thread;
-private import std.conv;
-private import std.string;
-
-class ReplayEntry {
-    int gameScore;
-    int turnScore;
-    int clearScore;
-    int leftScore;
-    int nomissScore;
-    int allScore;
-    long utcTime;
-    int patterns;
-
-    int endTurn;
-    int[] scoreStat;
-    enum ScoreStatEnc {
-        CSV, DIV_PRINTABLE95
-    }
-    ScoreStatEnc scoreStatEnc;
-
-    char[] mode;
-    long seed;
-    char[] inputs;
-
-    char[] pversion;
-    char[] name;
-    char[] date;
-
-    char[] filename;
-
-    int opCmp(Object o) {
-        ReplayEntry e = cast(ReplayEntry)o;
-        return (allScore < e.allScore) - (allScore > e.allScore);
-    }
-
-    void addHeaderLine(char[] line, char[] errmsg) {
-        char[][] kv = line.split(`: `);
-        char[] k = kv[0];
-        char[] v = join(kv[1..length], `: `);
-        switch (k) {
-        case `version`:
-            pversion = v; break;
-        case `score`:
-            allScore = toInt(v); break;
-        case `name`:
-            name = v; break;
-        case `date`:
-            date = v; break;
-        case `gameScore`:
-            gameScore = toInt(v); break;
-        case `turnScore`:
-            turnScore = toInt(v); break;
-        case `clearScore`:
-            clearScore = toInt(v); break;
-        case `leftScore`:
-            leftScore = toInt(v); break;
-        case `nomissScore`:
-            nomissScore = toInt(v); break;
-        case `turn`:
-            endTurn = toInt(v); break;
-        case `patterns`:
-            patterns = toInt(v); break;
-        case `seed`:
-            seed = toLong(v); break;
-        case `utcTime`:
-            utcTime = toLong(v); break;
-        case `mode`:
-            mode = v; break;
-        case `filename`:
-            filename = v; break;
-        case `inputEnc`:
-            break;
-        case `scoreStatEnc`:
-            if (v == `divPrintable95`)
-                scoreStatEnc = ScoreStatEnc.DIV_PRINTABLE95;
-            break;
-        case `scoreStat`:
-            if (scoreStatEnc == ScoreStatEnc.DIV_PRINTABLE95) {
-                int prev = 0;
-                for (int i = 0; i < v.length; i += 4) {
-                    int s = prev +
-                        (v[i+0]-32) +
-                        (v[i+1]-32)*95 +
-                        (v[i+2]-32)*95*95 +
-                        (v[i+3]-32)*95*95*95;
-                    scoreStat ~= s;
-                    prev = s;
-                }
-            }
-            else {
-                foreach (char[] s; v.split(`,`)) {
-                    if (s.length == 0) break;
-                    scoreStat ~= toInt(s);
-                }
-            }
-            break;
-        default:
-            Log.warn(k ~ `: unknown key in replay ` ~ errmsg);
-        }
-    }
-}
-
-abstract class ReplayDB {
-    void setSort(char[] mode, SceneSelect scene) {
-        sorted.length = 0;
-        foreach (ReplayEntry e; entries) {
-            if (e.mode == mode) sorted ~= e;
-        }
-        sorted.sort;
-
-        scene.setResultDisplay();
-    }
-
-    void prepareReplayFile(ReplayEntry entry) {}
-
-    bool isOk() { return ok_; }
-    bool isError() { return error_; }
-
-    ReplayEntry[] entries;
-    ReplayEntry[] sorted;
-
-    bool ok_;
-    bool error_;
-
-}
-
-private import std.stream;
-private import std.file;
-private import std.regexp;
-
-class LocalReplayDB : ReplayDB {
-    int load() {
-        RegExp rpyReg =
-            new RegExp(`^\d\d\d\d\d\d\d\d\d\d\d\d_[a-zA-Z0-9%]+\.rpy$`, ``);
-        foreach (char[] fname; listdir(`replay`)) {
-            if (!rpyReg.test(fname)) continue;
-
-            try {
-                ReplayEntry entry = new ReplayEntry();
-
-                File ifile = new File(`replay/` ~ fname);
-                char[] line;
-                while ((line = ifile.readLine).length != 0) {
-                    entry.addHeaderLine(line, fname);
-                }
-
-                ifile.close();
-
-                entries ~= entry;
-            }
-            catch (Object o) {
-                Log.warn(fname~": broken replay file ("~o.toString()~").");
-            }
-        }
-
-        ok_ = true;
-
-        error_ = entries.length == 0;
-
-        return 0;
-    }
-
-    this() {
-        ok_ = false;
-        thread_ = new Thread(&load);
-        thread_.start();
-    }
-
-    Thread thread_;
-}
-
-private import http;
-private import sino;
-private import rc;
-
-class NetReplayDB : ReplayDB {
-    this() {
-        ok_ = true;
-    }
-
-    override void setSort(char[] mode, SceneSelect scene) {
-        mode_ = mode;
-        ok_ = false;
-        scene_ = scene;
-        thread_ = new Thread(&load);
-        thread_.start();
-    }
-
-    int load() {
-        try {
-            char[] host = Sino.rc.get(`scoreServer`);
-            int port = Sino.rc.getInt(`scorePort`);
-            char[] dir = Sino.rc.get(`scorePath`);
-
-            Http h = new Http10(host, port);
-            char[] path = dir ~ `/scores_` ~ mode_ ~ `.txt`;
-            HttpResponse res = h.get(path);
-
-            Log.info(`score server status: ` ~ res.statusLine);
-
-            sorted.length = 0;
-            ReplayEntry e = new ReplayEntry();
-            foreach (char[] line; res.messageBody.split("\n")) {
-                if (line.length > 0) {
-                    e.addHeaderLine(line, path);
-                }
-                else {
-                    if (e.name) {
-                        sorted ~= e;
-                        e = new ReplayEntry();
-                    }
-                }
-            }
-
-            sorted.sort;
-
-            error_ = false;
-
-            scene_.setResultDisplay();
-        }
-        catch (Object o) {
-            Log.info(`cannot connect score server: ` ~ o.toString());
-            error_ = true;
-        }
-
-        ok_ = true;
-
-        return 0;
-    }
-
-    override void prepareReplayFile(ReplayEntry entry) {
-        ok_ = false;
-        entry_ = entry;
-        thread_ = new Thread(&prepare);
-        thread_.start();
-    }
-
-    private int prepare() {
-        try {
-            char[] rpyfile = `replay/` ~ entry_.filename;
-            if (std.file.exists(rpyfile)) {
-                ok_ = true;
-                return 0;
-            }
-
-            Log.info(rpyfile ~ `: get from score server`);
-
-            char[] host = Sino.rc.get(`scoreServer`);
-            int port = Sino.rc.getInt(`scorePort`);
-            char[] dir = Sino.rc.get(`scorePath`);
-
-            Http h = new Http10(host, port);
-            char[] path = dir ~ `/` ~ rpyfile;
-            path = path.replace(`%`, `%25`);
-            HttpResponse res = h.get(path);
-
-            char[] rpy = res.messageBody;
-            std.file.write(rpyfile, rpy);
-        }
-        catch (Object o) {
-            Log.info(`cannot get replay file: ` ~ o.toString());
-            error_ = true;
-        }
-
-        ok_ = true;
-
-        return 0;
-    }
-
-private:
-    Thread thread_;
-    char[] mode_;
-    SceneSelect scene_;
-    ReplayEntry entry_;
-}
diff -Naur psyno/src/scene_game.d psyno-gentoo/src/scene_game.d
--- psyno/src/scene_game.d	2004-11-13 19:13:12.000000000 +0100
+++ psyno-gentoo/src/scene_game.d	2007-09-23 12:20:45.000000000 +0200
@@ -1,11 +1,12 @@
 private import game;
 private import scene;
-private import log;
+private import scene_result;
+private import scene_select;
 
 class SceneGame : Scene {
 public:
     this() {
-        Log.info("scene game");
+      //  Log.info("scene game");
         game_ = new Game();
     }
 
diff -Naur psyno/src/scene_result.d psyno-gentoo/src/scene_result.d
--- psyno/src/scene_result.d	2004-11-27 05:57:35.000000000 +0100
+++ psyno-gentoo/src/scene_result.d	2007-09-23 12:22:06.000000000 +0200
@@ -1,5 +1,6 @@
 private import game;
 private import scene;
+private import scene_select;
 private import mygl;
 private import myglbf;
 private import sound;
@@ -21,7 +22,7 @@
 class SceneResult : Scene {
 public:
     this(Game game) {
-        Log.info("scene result");
+    //    Log.info("scene result");
         Sound.obj.fadeMusic();
 
         game_ = game;
@@ -231,16 +232,16 @@
         if (httpThread.isEnd()) {
             HttpResponse res = httpThread.response;
 
-            Log.info(`score server status: ` ~ res.statusLine);
+//            Log.info(`score server status: ` ~ res.statusLine);
             status_ = strip(res.messageBody);
-            Log.info(status_);
+//            Log.info(status_);
         }
         else if (httpThread.isError()) {
-            Log.info("err");
+  //          Log.info("err");
             status_ = `ERROR`;
         }
         else if (httpThread.isTimeout()) {
-            Log.info("timeout");
+    //        Log.info("timeout");
             status_ = `TIMEOUT`;
         }
         else {
@@ -408,7 +409,7 @@
             }
         }
         catch (Object o) {
-            Log.warn("exception in name entry: " ~ o.toString());
+//            Log.warn("exception in name entry: " ~ o.toString());
         }
     }
 
@@ -432,7 +433,7 @@
         char[] dt = formatDate(d);
         char[] encname = fnEncode(name_);
         fname_ = dt ~ "_" ~ encname ~ ".rpy";
-        Log.info("replay save to replay/" ~ fname_);
+//        Log.info("replay save to replay/" ~ fname_);
 
         File ofile = new File("replay/" ~ fname_, FileMode.OutNew);
         with (result_) {
@@ -470,7 +471,7 @@
         game_.saveReplay(ofile);
         ofile.close();
 
-        Log.info("replay save end");
+//        Log.info("replay save end");
     }
 
 private:
diff -Naur psyno/src/scene_select.d psyno-gentoo/src/scene_select.d
--- psyno/src/scene_select.d	2004-12-01 01:09:52.000000000 +0100
+++ psyno-gentoo/src/scene_select.d	2007-09-23 12:31:28.000000000 +0200
@@ -1,11 +1,11 @@
 private import scene;
+private import scene_game;
 private import common;
 private import sino;
 private import rc;
 private import mygl;
 private import myglbf;
 private import game;
-private import replaydb;
 private import result_display;
 private import sound;
 
@@ -17,7 +17,7 @@
 class SceneSelect : Scene {
 public:
     this() {
-        Log.info("scene select");
+    //    Log.info("scene select");
         isEnd_ = false;
 
         origNoSound_ = Sino.rc.get(`noSound`);
@@ -79,7 +79,7 @@
             state_ == State.REPLAY_PREPARE)
         {
             draws_.draw();
-            doReplay();
+//            doReplay();
             return;
         }
 
@@ -126,7 +126,7 @@
             doMenu();
         }
     }
-
+/*
     void setResultDisplay() {
         if (replayDB_.sorted.length == 0) {
             return;
@@ -154,12 +154,13 @@
             dst.date = src.date;
         }
         copyEntry(replayDB_.sorted[replayIte_], result_);
+*/
 /*
         copyEntry!(ReplayDB.Entry, ResultDisplay)
             (replayDB_.sorted[replayIte_], result_);
 */
-        result_.init();
-    }
+//        result_.init();
+//    }
 
     private void doMsg(char[] msg) {
         glDisable(GL_TEXTURE_2D);
@@ -203,7 +204,7 @@
 
         drawStringC(msg, 240, 260, 14, 18, 1,1,1, elapsed/30);
     }
-
+/*
     void doReplay() {
         drawString(`Select mode`, 50, 50, 10, 12, 1, 1, 1, 0.9);
         char[][] modes;
@@ -352,7 +353,7 @@
             }
         }
     }
-
+*/
     void doMenu() {
         char[][] menu;
         menu ~= `EASY MODE`;
@@ -396,7 +397,7 @@
                     Sino.rc.set(`gameMode`, `endless`);
                 }
             }
-            else if (h_ == 3) {
+/*            else if (h_ == 3) {
                 replayDB_ = new LocalReplayDB();
                 state_ = State.REPLAY_MODE;
                 stateStartTurn_ = Sino.obj.timer.getTurn;
@@ -406,6 +407,7 @@
                 state_ = State.REPLAY_MODE;
                 stateStartTurn_ = Sino.obj.timer.getTurn;
             }
+*/
         }
 
 /*
@@ -452,8 +454,8 @@
     State state_;
     int stateStartTurn_;
 
-    ReplayDB replayDB_;
-    int replayIte_;
+//    ReplayDB replayDB_;
+//    int replayIte_;
 
     ResultDisplay result_;
     int replayMode_;
diff -Naur psyno/src/sdl/SDL.d psyno-gentoo/src/sdl/SDL.d
--- psyno/src/sdl/SDL.d	2004-09-01 15:36:20.000000000 +0200
+++ psyno-gentoo/src/sdl/SDL.d	2007-09-07 12:05:38.000000000 +0200
@@ -20,71 +20,76 @@
     slouken@devolution.com
 */
 
-import SDL_types;
-import SDL_getenv;
-import SDL_error;
-import SDL_rwops;
-import SDL_timer;
-import SDL_audio;
-import SDL_cdrom;
-import SDL_joystick;
-import SDL_events;
-import SDL_video;
-import SDL_byteorder;
-import SDL_Version;
-
-extern(C):
-
-/* As of version 0.5, SDL is loaded dynamically into the application */
-
-/* These are the flags which may be passed to SDL_Init() -- you should
-   specify the subsystems which you will be using in your application.
-*/
-const uint SDL_INIT_TIMER		= 0x00000001;
-const uint SDL_INIT_AUDIO		= 0x00000010;
-const uint SDL_INIT_VIDEO		= 0x00000020;
-const uint SDL_INIT_CDROM		= 0x00000100;
-const uint SDL_INIT_JOYSTICK	= 0x00000200;
-const uint SDL_INIT_NOPARACHUTE	= 0x00100000;	/* Don't catch fatal signals */
-const uint SDL_INIT_EVENTTHREAD	= 0x01000000;	/* Not supported on all OS's */
-const uint SDL_INIT_EVERYTHING	= 0x0000FFFF;
-
-/* This function loads the SDL dynamically linked library and initializes 
- * the subsystems specified by 'flags' (and those satisfying dependencies)
- * Unless the SDL_INIT_NOPARACHUTE flag is set, it will install cleanup
- * signal handlers for some commonly ignored fatal signals (like SIGSEGV)
- */
-int SDL_Init(Uint32 flags);
-
-/* This function initializes specific SDL subsystems */
-int SDL_InitSubSystem(Uint32 flags);
-
-/* This function cleans up specific SDL subsystems */
-void SDL_QuitSubSystem(Uint32 flags);
-
-/* This function returns mask of the specified subsystems which have
-   been initialized.
-   If 'flags' is 0, it returns a mask of all initialized subsystems.
-*/
-Uint32 SDL_WasInit(Uint32 flags);
-
-/* This function cleans up all initialized subsystems and unloads the
- * dynamically linked library.  You should call it upon all exit conditions.
- */
-void SDL_Quit();
-
-void SDL_SetModuleHandle(void *hInst);
-extern(Windows) void* GetModuleHandle(char*);
-
-static this()
-{
-	/* Load SDL dynamic link library */
-	if (SDL_Init(SDL_INIT_NOPARACHUTE) < 0)
-		throw new Error("Error loading SDL");
-	SDL_SetModuleHandle(GetModuleHandle(null));
-}
-
-static ~this()
-{
-	SDL_Quit();
-}
+public import SDL_types;
+public import SDL_getenv;
+public import SDL_error;
+public import SDL_rwops;
+public import SDL_timer;
+public import SDL_audio;
+public import SDL_cdrom;
+public import SDL_joystick;
+public import SDL_events;
+public import SDL_video;
+public import SDL_byteorder;
+public import SDL_Version;
+public import SDL_Keysym;
+public import SDL_keyboard;
+public import SDL_mouse;
+
+extern(C):
+
+/* As of version 0.5, SDL is loaded dynamically into the application */
+
+/* These are the flags which may be passed to SDL_Init() -- you should
+   specify the subsystems which you will be using in your application.
+*/
+const uint SDL_INIT_TIMER		= 0x00000001;
+const uint SDL_INIT_AUDIO		= 0x00000010;
+const uint SDL_INIT_VIDEO		= 0x00000020;
+const uint SDL_INIT_CDROM		= 0x00000100;
+const uint SDL_INIT_JOYSTICK	= 0x00000200;
+const uint SDL_INIT_NOPARACHUTE	= 0x00100000;	/* Don't catch fatal signals */
+const uint SDL_INIT_EVENTTHREAD	= 0x01000000;	/* Not supported on all OS's */
+const uint SDL_INIT_EVERYTHING	= 0x0000FFFF;
+
+/* This function loads the SDL dynamically linked library and initializes 
+ * the subsystems specified by 'flags' (and those satisfying dependencies)
+ * Unless the SDL_INIT_NOPARACHUTE flag is set, it will install cleanup
+ * signal handlers for some commonly ignored fatal signals (like SIGSEGV)
+ */
+int SDL_Init(Uint32 flags);
+
+/* This function initializes specific SDL subsystems */
+int SDL_InitSubSystem(Uint32 flags);
+
+/* This function cleans up specific SDL subsystems */
+void SDL_QuitSubSystem(Uint32 flags);
+
+/* This function returns mask of the specified subsystems which have
+   been initialized.
+   If 'flags' is 0, it returns a mask of all initialized subsystems.
+*/
+Uint32 SDL_WasInit(Uint32 flags);
+
+/* This function cleans up all initialized subsystems and unloads the
+ * dynamically linked library.  You should call it upon all exit conditions.
+ */
+void SDL_Quit();
+
+/+
+void SDL_SetModuleHandle(void *hInst);
+extern(Windows) void* GetModuleHandle(char*);
+
+static this()
+{
+	/* Load SDL dynamic link library */
+	if (SDL_Init(SDL_INIT_NOPARACHUTE) < 0)
+		throw new Error("Error loading SDL");
+	SDL_SetModuleHandle(GetModuleHandle(null));
+}
+
+static ~this()
+{
+	SDL_Quit();
+}
++/
diff -Naur psyno/src/sdl/SDL_endian.d psyno-gentoo/src/sdl/SDL_endian.d
--- psyno/src/sdl/SDL_endian.d	2004-09-01 15:36:20.000000000 +0200
+++ psyno-gentoo/src/sdl/SDL_endian.d	2007-09-22 14:24:05.000000000 +0200
@@ -22,7 +22,7 @@
 
 /* Functions for reading and writing endian-specific values */
 
-/* These functions read and write data of the specified endianness, 
+/* These functions read and write data of the specified endianness,
    dynamically translating to the host machine endianness.
 
    e.g.: If you want to read a 16 bit value on big-endian machine from
@@ -30,7 +30,7 @@
 		value = SDL_ReadLE16(rp);
          Note that the read/write functions use SDL_RWops pointers
          instead of FILE pointers.  This allows you to read and write
-         endian values from large chunks of memory as well as files 
+         endian values from large chunks of memory as well as files
          and other data sources.
 */
 
@@ -46,9 +46,9 @@
    header should only be included in files that actually use them.
 */
 
-Uint16 SDL_Swap16(Uint16 D) {
-	return((D<<8)|(D>>8));
-}
+//Uint16 SDL_Swap16(Uint16 D) {
+//	return((D<<8)|(D>>8));
+//}
 
 Uint32 SDL_Swap32(Uint32 D) {
 	return((D<<24)|((D<<8)&0x00FF0000)|((D>>8)&0x0000FF00)|(D>>24));
@@ -73,7 +73,7 @@
 //#define SDL_SwapBE16(X)	SDL_Swap16(X)
 //#define SDL_SwapBE32(X)	SDL_Swap32(X)
 //#define SDL_SwapBE64(X)	SDL_Swap64(X)
-Uint16 SDL_SwapLE16(Uint16 X) { return SDL_Swap16(X); }
+//Uint16 SDL_SwapLE16(Uint16 X) { return SDL_Swap16(X); }
 Uint32 SDL_SwapLE32(Uint32 X) { return SDL_Swap32(X); }
 Uint64 SDL_SwapLE64(Uint64 X) { return SDL_Swap64(X); }
 Uint16 SDL_SwapBE16(Uint16 X) { return (X); }
diff -Naur psyno/src/sdl/SDL_events.d psyno-gentoo/src/sdl/SDL_events.d
--- psyno/src/sdl/SDL_events.d	2004-12-02 15:56:43.000000000 +0100
+++ psyno-gentoo/src/sdl/SDL_events.d	2002-01-04 15:59:20.000000000 +0100
@@ -304,8 +304,8 @@
   If 'state' is set to SDL_QUERY, SDL_EventState() will return the 
   current processing state of the specified event.
 */
-const int SDL_QUERY	= -1;
-const int SDL_IGNORE	= 0;
-const int SDL_DISABLE	= 0;
-const int SDL_ENABLE	= 1;
+const uint SDL_QUERY	= -1;
+const uint SDL_IGNORE	= 0;
+const uint SDL_DISABLE	= 0;
+const uint SDL_ENABLE	= 1;
 Uint8 SDL_EventState(Uint8 type, int state);
diff -Naur psyno/src/sdl/SDL_image.d psyno-gentoo/src/sdl/SDL_image.d
--- psyno/src/sdl/SDL_image.d	1970-01-01 01:00:00.000000000 +0100
+++ psyno-gentoo/src/sdl/SDL_image.d	2004-05-08 14:09:32.000000000 +0200
@@ -0,0 +1,84 @@
+/*
+  SDL_image:  An example image loading library for use with SDL
+  Copyright (C) 1999, 2000, 2001  Sam Lantinga
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Library General Public
+  License as published by the Free Software Foundation; either
+  version 2 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Library General Public License for more details.
+
+  You should have received a copy of the GNU Library General Public
+  License along with this library; if not, write to the Free
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+  Sam Lantinga
+  slouken@libsdl.org
+*/
+
+/* $Id: SDL_image.h,v 1.13 2002/04/13 15:06:00 slouken Exp $ */
+
+// convert to D by shinichiro.h
+
+/* A simple library to load images of various formats as SDL surfaces */
+
+import SDL;
+
+extern (C) {
+
+/* Load an image from an SDL data source.
+   The 'type' may be one of: "BMP", "GIF", "PNG", etc.
+
+   If the image format supports a transparent pixel, SDL will set the
+   colorkey for the surface.  You can enable RLE acceleration on the
+   surface afterwards by calling:
+   SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);
+*/
+	SDL_Surface * IMG_LoadTyped_RW(SDL_RWops *src, int freesrc, char *type);
+/* Convenience functions */
+	SDL_Surface * IMG_Load(char *file);
+	SDL_Surface * IMG_Load_RW(SDL_RWops *src, int freesrc);
+
+/* Invert the alpha of a surface for use with OpenGL
+   This function is now a no-op, and only provided for backwards compatibility.
+*/
+	int IMG_InvertAlpha(int on);
+
+/* Functions to detect a file type, given a seekable source */
+	int IMG_isBMP(SDL_RWops *src);
+	int IMG_isPNM(SDL_RWops *src);
+	int IMG_isXPM(SDL_RWops *src);
+	int IMG_isXCF(SDL_RWops *src);
+	int IMG_isPCX(SDL_RWops *src);
+	int IMG_isGIF(SDL_RWops *src);
+	int IMG_isJPG(SDL_RWops *src);
+	int IMG_isTIF(SDL_RWops *src);
+	int IMG_isPNG(SDL_RWops *src);
+	int IMG_isLBM(SDL_RWops *src);
+
+/* Individual loading functions */
+	SDL_Surface * IMG_LoadBMP_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadPNM_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadXPM_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadXCF_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadPCX_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadGIF_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadJPG_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadTIF_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadPNG_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadTGA_RW(SDL_RWops *src);
+	SDL_Surface * IMG_LoadLBM_RW(SDL_RWops *src);
+
+	SDL_Surface * IMG_ReadXPMFromArray(char **xpm);
+
+/* We'll use SDL for reporting errors */
+//#define IMG_SetError	SDL_SetError
+	char* IMG_GetError() {
+		return SDL_GetError();
+	}
+
+}
diff -Naur psyno/src/sdl/SDL_mixer.d psyno-gentoo/src/sdl/SDL_mixer.d
--- psyno/src/sdl/SDL_mixer.d	2004-09-01 15:37:24.000000000 +0200
+++ psyno-gentoo/src/sdl/SDL_mixer.d	2007-09-07 12:05:52.000000000 +0200
@@ -22,7 +22,7 @@
 
 // convert to D by shinichiro.h
 
-/* $Id: SDL_mixer.d,v 1.1 2003/12/21 15:17:50 i Exp $ */
+/* $Id: SDL_mixer.h,v 1.24 2002/05/21 05:45:59 slouken Exp $ */
 
 import SDL;
 
diff -Naur psyno/src/sdl/SDL_pad.d psyno-gentoo/src/sdl/SDL_pad.d
--- psyno/src/sdl/SDL_pad.d	2004-11-24 16:33:21.000000000 +0100
+++ psyno-gentoo/src/sdl/SDL_pad.d	2007-09-21 16:06:53.000000000 +0200
@@ -1,7 +1,7 @@
-/** @@@
- * @@@ が付いてるのは一時的なコメント
- * SDL_pad と名前を付けるのは頑張って作るという気合いのあらわれ
- * デザイン的には愚直に普通にを目指す
+/**
+ * 
+ * SDL_pad 
+ *
  */
 
 private import SDL;
@@ -18,9 +18,9 @@
 }
 
 enum {
-	/** @@@
-	 * もっと気のきいた名前がいいなあ…
-	 * あとこれらの値はどうする？
+	/**
+	 * 
+	 * 
 	 * 0, 1, 2, 3, 4, 5, 6, 7, 8 ?
 	 * 0, 1, 5, 4, 6, 2, 10, 8, 9 ?
 	 */
@@ -374,113 +374,60 @@
 	PAD_END_BUTTON
 }
 
-/** @@@
- * まずボタンの概念について
- * キーボード、ジョイスティック、マウス左中右、SDL_QUIT をボタンと呼ぶ
- * ユーザボタンは押されているか押されていないかで 0 か 1 の値を持つ
- * ユーザボタンは複数のボタンの論理 OR によって実現される
- * ユーザボタンには ID がありこれらは自動的に割当てられる
- * デフォルトの ID は単一のボタンによっている
- */
 
-/** @@@
- * 初期化
- */
 int Pad_Init();
 
-/** @@@
- * 更新
- * @param flags PAD_PUMP_* の論理和。
- */
+
 void Pad_Pump(Uint32 flags);
 
-/**
- * @return 正なら押されている。 1 なら今回押された。
- *         非正なら離されている。 0 なら今回離された。
- */
+
 int Pad_GetButton(int id);
 
-/**
- * Push と Pull は瞬間
- */
+
 int Pad_GetButtonPushed(int id);
 int Pad_GetButtonPressed(int id);
 int Pad_GetButtonPulled(int id);
 int Pad_GetButtonReleased(int id);
 
-/** @@@
- * 正の ID はユーザが登録することができる
- * よって引数 id は正である必要がある
- * 引数 addid は負である必要があっても良いと思う
- * 一つのユーザボタンに 8 個以上ボタンは登録できません
- * あとユーザボタンは 80 個まで
- */
+
 int Pad_AddButton(int id, int addid);
 
 int Pad_GetAxis(int id);
 
 void Pad_AddAxis(int id, int upid, int rightid, int downid, int leftid);
 
-/** @@@
- * いくつかのヘルパ
- * 組み合わせが使えないから不便
- */
+
 void Pad_AddAxisKeyboardArrow(int id);
 void Pad_AddAxisKeyboardRogue(int id);
 void Pad_AddAxisKeyboardWASD(int id);
 void Pad_AddAxisJoystick1(int id);
 void Pad_AddAxisJoystick2(int id);
 
-/** @@@
- * 設定読み出し
- */
+
 int Pad_LoadDefault(char* file);
-/** @@@
- * マッピングつき設定読み出し
- */
+
 int Pad_Load(char* file, char** bnames, char** anames);
 
 int Pad_LoadRW(SDL_RWops* op, char** bnames, char** anames);
 
-/** @@@
- * 設定書き出し
- */
+
 int Pad_SaveDefault(char* file);
-/** @@@
- * マッピングつき設定書き出し
- */
+
 int Pad_Save(char* file, char** bnames, char** anames);
 
 int Pad_SaveRW(SDL_RWops* op, char** bnames, char** anames);
 
-/** @@@
- * 以上の設定をいろんな PAD アプリで共通に行う機構が欲しい
- * 例えば A ボタンは Z 、 B ボタンは X が好みなユーザは
- * 他のゲームでもその配置を使いたい。
- * .sdlpad のクロスプラットホームな位置特定を自動でする必要がある
- * 後 NES なんかは右から A, B と非常識な並びなのですけど、
- * そのへんは問題にならないかな？
- */
 
-/** @@@
- * ラップレイヤ
- */
 Sint16 Pad_JoystickGetAxis(SDL_Joystick* joystick, int axis, Uint32 mode);
 Uint8 Pad_JoystickGetButton(SDL_Joystick* joystick, int button);
 
-/** @@@
- * ジョイスティックの threshold を設定する
- * @param val 正数で入力
- */
+
 void Pad_SetJoystickThresholdUp(int val);
 void Pad_SetJoystickThresholdRight(int val);
 void Pad_SetJoystickThresholdDown(int val);
 void Pad_SetJoystickThresholdLeft(int val);
 
-/** @@@
- * イベントから PadKey を取り出す
- * Event handling モデルで扱う場合は存外便利だったので
- */
+
 PadKey Pad_PadKeyFromEvent(SDL_Event* ev);
 
 char* Pad_GetError() {
diff -Naur psyno/src/sdl/SDL_sound.d psyno-gentoo/src/sdl/SDL_sound.d
--- psyno/src/sdl/SDL_sound.d	1970-01-01 01:00:00.000000000 +0100
+++ psyno-gentoo/src/sdl/SDL_sound.d	2004-05-08 14:09:58.000000000 +0200
@@ -0,0 +1,651 @@
+/** \file SDL_sound.h */
+
+/*
+ * SDL_sound -- An abstract sound format decoding API.
+ * Copyright (C) 2001  Ryan C. Gordon.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/**
+ * \mainpage SDL_sound
+ *
+ * The latest version of SDL_sound can be found at:
+ *     http://icculus.org/SDL_sound/
+ *
+ * The basic gist of SDL_sound is that you use an SDL_RWops to get sound data
+ *  into this library, and SDL_sound will take that data, in one of several
+ *  popular formats, and decode it into raw waveform data in the format of
+ *  your choice. This gives you a nice abstraction for getting sound into your
+ *  game or application; just feed it to SDL_sound, and it will handle
+ *  decoding and converting, so you can just pass it to your SDL audio
+ *  callback (or whatever). Since it gets data from an SDL_RWops, you can get
+ *  the initial sound data from any number of sources: file, memory buffer,
+ *  network connection, etc.
+ *
+ * As the name implies, this library depends on SDL: Simple Directmedia Layer,
+ *  which is a powerful, free, and cross-platform multimedia library. It can
+ *  be found at http://www.libsdl.org/
+ *
+ * Support is in place or planned for the following sound formats:
+ *   - .WAV  (Microsoft WAVfile RIFF data, internal.)
+ *   - .VOC  (Creative Labs' Voice format, internal.)
+ *   - .MP3  (MPEG-1 Layer 3 support, via the SMPEG and mpglib libraries.)
+ *   - .MID  (MIDI music converted to Waveform data, internal.)
+ *   - .MOD  (MOD files, via MikMod and ModPlug.)
+ *   - .OGG  (Ogg files, via Ogg Vorbis libraries.)
+ *   - .SHN  (Shorten files, internal.)
+ *   - .RAW  (Raw sound data in any format, internal.)
+ *   - .AU   (Sun's Audio format, internal.)
+ *   - .AIFF (Audio Interchange format, internal.)
+ *   - .FLAC (Lossless audio compression, via libFLAC.)
+ *
+ *   (...and more to come...)
+ *
+ * Please see the file COPYING in the source's root directory.
+ *
+ * \author Ryan C. Gordon (icculus@clutteredmind.org)
+ * \author many others, please see CREDITS in the source's root directory.
+ */
+
+// convert to D by shinichiro.h
+
+import SDL;
+
+extern (C) {
+	const int SOUND_VER_MAJOR = 1;
+	const int SOUND_VER_MINOR = 0;
+	const int SOUND_VER_PATCH = 0;
+
+
+/**
+ * \enum Sound_SampleFlags
+ * \brief Flags that are used in a Sound_Sample to show various states.
+ *
+ * To use:
+ * \code
+ * if (sample->flags & SOUND_SAMPLEFLAG_ERROR) { dosomething(); }
+ * \endcode
+ *
+ * \sa Sound_SampleNew
+ * \sa Sound_SampleNewFromFile
+ * \sa Sound_SampleDecode
+ * \sa Sound_SampleDecodeAll
+ * \sa Sound_SampleSeek
+ */
+	enum {
+		SOUND_SAMPLEFLAG_NONE    = 0,       /**< No special attributes. */
+
+		/* these are set at sample creation time... */
+		SOUND_SAMPLEFLAG_CANSEEK = 1,       /**< Sample can seek to arbitrary points. */
+
+		/* these are set during decoding... */
+		SOUND_SAMPLEFLAG_EOF     = 1 << 29, /**< End of input stream. */
+		SOUND_SAMPLEFLAG_ERROR   = 1 << 30, /**< Unrecoverable error. */
+		SOUND_SAMPLEFLAG_EAGAIN  = 1 << 31  /**< Function would block, or temp error. */
+	}
+	alias int Sound_SampleFlags;
+
+
+/**
+ * \struct Sound_AudioInfo
+ * \brief Information about an existing sample's format.
+ *
+ * These are the basics of a decoded sample's data structure: data format
+ *  (see AUDIO_U8 and friends in SDL_audio.h), number of channels, and sample
+ *  rate. If you need more explanation than that, you should stop developing
+ *  sound code right now.
+ *
+ * \sa Sound_SampleNew
+ * \sa Sound_SampleNewFromFile
+ */
+	struct Sound_AudioInfo
+	{
+		Uint16 format;  /**< Equivalent of SDL_AudioSpec.format. */
+		Uint8 channels; /**< Number of sound channels. 1 == mono, 2 == stereo. */
+		Uint32 rate;    /**< Sample rate; frequency of sample points per second. */
+	}
+
+
+/**
+ * \struct Sound_DecoderInfo
+ * \brief Information about available soudn decoders.
+ *
+ * Each decoder sets up one of these structs, which can be retrieved via
+ *  the Sound_AvailableDecoders() function. EVERY FIELD IN THIS IS READ-ONLY.
+ *
+ * The extensions field is a NULL-terminated list of ASCIZ strings. You
+ *  should read it like this:
+ *
+ * \code
+ * const char **ext;
+ * for (ext = info->extensions; *ext != NULL; ext++) {
+ *     printf("   File extension \"%s\"\n", *ext);
+ * }
+ * \endcode
+ *
+ * \sa Sound_AvailableDecoders
+ */
+	struct Sound_DecoderInfo
+	{
+		const char **extensions; /**< File extensions, list ends with NULL. */
+		const char *description; /**< Human readable description of decoder. */
+		const char *author;      /**< "Name Of Author \<email@emailhost.dom\>" */
+		const char *url;         /**< URL specific to this decoder. */
+	}
+
+
+
+/**
+ * \struct Sound_Sample
+ * \brief Represents sound data in the process of being decoded.
+ *
+ * The Sound_Sample structure is the heart of SDL_sound. This holds
+ *  information about a source of sound data as it is being decoded.
+ *  EVERY FIELD IN THIS IS READ-ONLY. Please use the API functions to
+ *  change them.
+ */
+	struct Sound_Sample
+	{
+		void *opaque;  /**< Internal use only. Don't touch. */
+		const Sound_DecoderInfo *decoder;  /**< Decoder used for this sample. */
+		Sound_AudioInfo desired;  /**< Desired audio format for conversion. */
+		Sound_AudioInfo actual;  /**< Actual audio format of sample. */
+		void *buffer;  /**< Decoded sound data lands in here. */
+		Uint32 buffer_size;  /**< Current size of (buffer), in bytes (Uint8). */
+		Sound_SampleFlags flags;  /**< Flags relating to this sample. */
+	}
+
+
+/**
+ * \struct Sound_Version
+ * \brief Information the version of SDL_sound in use.
+ *
+ * Represents the library's version as three levels: major revision
+ *  (increments with massive changes, additions, and enhancements),
+ *  minor revision (increments with backwards-compatible changes to the
+ *  major revision), and patchlevel (increments with fixes to the minor
+ *  revision).
+ *
+ * \sa SOUND_VERSION
+ * \sa Sound_GetLinkedVersion
+ */
+	struct Sound_Version
+	{
+		int major; /**< major revision */
+		int minor; /**< minor revision */
+		int patch; /**< patchlevel */
+	}
+
+
+/* functions and macros... */
+
+/**
+ * \def SOUND_VERSION(x)
+ * \brief Macro to determine SDL_sound version program was compiled against.
+ *
+ * This macro fills in a Sound_Version structure with the version of the
+ *  library you compiled against. This is determined by what header the
+ *  compiler uses. Note that if you dynamically linked the library, you might
+ *  have a slightly newer or older version at runtime. That version can be
+ *  determined with Sound_GetLinkedVersion(), which, unlike SOUND_VERSION,
+ *  is not a macro.
+ *
+ * \param x A pointer to a Sound_Version struct to initialize.
+ *
+ * \sa Sound_Version
+ * \sa Sound_GetLinkedVersion
+ */
+	void SOUND_VERSION(Sound_Version x) {
+		x.major = SOUND_VER_MAJOR;
+		x.minor = SOUND_VER_MINOR;
+		x.patch = SOUND_VER_PATCH;
+	}
+
+
+/**
+ * \fn void Sound_GetLinkedVersion(Sound_Version *ver)
+ * \brief Get the version of SDL_sound that is linked against your program.
+ *
+ * If you are using a shared library (DLL) version of SDL_sound, then it is
+ *  possible that it will be different than the version you compiled against.
+ *
+ * This is a real function; the macro SOUND_VERSION tells you what version
+ *  of SDL_sound you compiled against:
+ *
+ * \code
+ * Sound_Version compiled;
+ * Sound_Version linked;
+ *
+ * SOUND_VERSION(&compiled);
+ * Sound_GetLinkedVersion(&linked);
+ * printf("We compiled against SDL_sound version %d.%d.%d ...\n",
+ *           compiled.major, compiled.minor, compiled.patch);
+ * printf("But we linked against SDL_sound version %d.%d.%d.\n",
+ *           linked.major, linked.minor, linked.patch);
+ * \endcode
+ *
+ * This function may be called safely at any time, even before Sound_Init().
+ *
+ * \param ver Sound_Version structure to fill with shared library's version.
+ *
+ * \sa Sound_Version
+ * \sa SOUND_VERSION
+ */
+	void Sound_GetLinkedVersion(Sound_Version *ver);
+
+
+/**
+ * \fn Sound_Init()
+ * \brief Initialize SDL_sound.
+ *
+ * This must be called before any other SDL_sound function (except perhaps
+ *  Sound_GetLinkedVersion()). You should call SDL_Init() before calling this.
+ *  Sound_Init() will attempt to call SDL_Init(SDL_INIT_AUDIO), just in case.
+ *  This is a safe behaviour, but it may not configure SDL to your liking by
+ *  itself.
+ *
+ * \return nonzero on success, zero on error. Specifics of the
+ *         error can be gleaned from Sound_GetError().
+ *
+ * \sa Sound_Quit
+ */
+	int Sound_Init();
+
+
+/**
+ * \fn Sound_Quit()
+ * \brief Shutdown SDL_sound.
+ *
+ * This closes any SDL_RWops that were being used as sound sources, and frees
+ *  any resources in use by SDL_sound.
+ *
+ * All Sound_Sample pointers you had prior to this call are INVALIDATED.
+ *
+ * Once successfully deinitialized, Sound_Init() can be called again to
+ *  restart the subsystem. All default API states are restored at this
+ *  point.
+ *
+ * You should call this BEFORE SDL_Quit(). This will NOT call SDL_Quit()
+ *  for you!
+ *
+ *  \return nonzero on success, zero on error. Specifics of the error
+ *          can be gleaned from Sound_GetError(). If failure, state of
+ *          SDL_sound is undefined, and probably badly screwed up.
+ *
+ * \sa Sound_Init
+ */
+	int Sound_Quit();
+
+
+/**
+ * \fn const Sound_DecoderInfo **Sound_AvailableDecoders()
+ * \brief Get a list of sound formats supported by this version of SDL_sound.
+ *
+ * This is for informational purposes only. Note that the extension listed is
+ *  merely convention: if we list "MP3", you can open an MPEG-1 Layer 3 audio
+ *  file with an extension of "XYZ", if you like. The file extensions are
+ *  informational, and only required as a hint to choosing the correct
+ *  decoder, since the sound data may not be coming from a file at all, thanks
+ *  to the abstraction that an SDL_RWops provides.
+ *
+ * The returned value is an array of pointers to Sound_DecoderInfo structures,
+ *  with a NULL entry to signify the end of the list:
+ *
+ * \code
+ * Sound_DecoderInfo **i;
+ *
+ * for (i = Sound_AvailableDecoders(); *i != NULL; i++)
+ * {
+ *     printf("Supported sound format: [%s], which is [%s].\n",
+ *              i->extension, i->description);
+ *     // ...and other fields...
+ * }
+ * \endcode
+ *
+ * The return values are pointers to static internal memory, and should
+ *  be considered READ ONLY, and never freed.
+ *
+ * \return READ ONLY Null-terminated array of READ ONLY structures.
+ *
+ * \sa Sound_DecoderInfo
+ */
+	Sound_DecoderInfo ** Sound_AvailableDecoders();
+
+
+/**
+ * \fn const char *Sound_GetError()
+ * \brief Get the last SDL_sound error message as a null-terminated string.
+ *
+ * This will be NULL if there's been no error since the last call to this
+ *  function. The pointer returned by this call points to an internal buffer,
+ *  and should not be deallocated. Each thread has a unique error state
+ *  associated with it, but each time a new error message is set, it will
+ *  overwrite the previous one associated with that thread. It is safe to call
+ *  this function at anytime, even before Sound_Init().
+ *
+ * \return READ ONLY string of last error message.
+ *
+ * \sa Sound_ClearError
+ */
+	char * Sound_GetError();
+
+
+/**
+ * \fn void Sound_ClearError()
+ * \brief Clear the current error message.
+ *
+ * The next call to Sound_GetError() after Sound_ClearError() will return NULL.
+ *
+ * \sa Sound_GetError
+ */
+	void Sound_ClearError();
+
+
+/**
+ * \fn Sound_Sample *Sound_NewSample(SDL_RWops *rw, const char *ext, Sound_AudioInfo *desired, Uint32 bufferSize)
+ * \brief Start decoding a new sound sample.
+ *
+ * The data is read via an SDL_RWops structure (see SDL_rwops.h in the SDL
+ *  include directory), so it may be coming from memory, disk, network stream,
+ *  etc. The (ext) parameter is merely a hint to determining the correct
+ *  decoder; if you specify, for example, "mp3" for an extension, and one of
+ *  the decoders lists that as a handled extension, then that decoder is given
+ *  first shot at trying to claim the data for decoding. If none of the
+ *  extensions match (or the extension is NULL), then every decoder examines
+ *  the data to determine if it can handle it, until one accepts it. In such a
+ *  case your SDL_RWops will need to be capable of rewinding to the start of
+ *  the stream.
+ *
+ * If no decoders can handle the data, a NULL value is returned, and a human
+ *  readable error message can be fetched from Sound_GetError().
+ *
+ * Optionally, a desired audio format can be specified. If the incoming data
+ *  is in a different format, SDL_sound will convert it to the desired format
+ *  on the fly. Note that this can be an expensive operation, so it may be
+ *  wise to convert data before you need to play it back, if possible, or
+ *  make sure your data is initially in the format that you need it in.
+ *  If you don't want to convert the data, you can specify NULL for a desired
+ *  format. The incoming format of the data, preconversion, can be found
+ *  in the Sound_Sample structure.
+ *
+ * Note that the raw sound data "decoder" needs you to specify both the
+ *  extension "RAW" and a "desired" format, or it will refuse to handle
+ *  the data. This is to prevent it from catching all formats unsupported
+ *  by the other decoders.
+ *
+ * Finally, specify an initial buffer size; this is the number of bytes that
+ *  will be allocated to store each read from the sound buffer. The more you
+ *  can safely allocate, the more decoding can be done in one block, but the
+ *  more resources you have to use up, and the longer each decoding call will
+ *  take. Note that different data formats require more or less space to
+ *  store. This buffer can be resized via Sound_SetBufferSize() ...
+ *
+ * The buffer size specified must be a multiple of the size of a single
+ *  sample point. So, if you want 16-bit, stereo samples, then your sample
+ *  point size is (2 channels * 16 bits), or 32 bits per sample, which is four
+ *  bytes. In such a case, you could specify 128 or 132 bytes for a buffer,
+ *  but not 129, 130, or 131 (although in reality, you'll want to specify a
+ *  MUCH larger buffer).
+ *
+ * When you are done with this Sound_Sample pointer, you can dispose of it
+ *  via Sound_FreeSample().
+ *
+ * You do not have to keep a reference to (rw) around. If this function
+ *  suceeds, it stores (rw) internally (and disposes of it during the call
+ *  to Sound_FreeSample()). If this function fails, it will dispose of the
+ *  SDL_RWops for you.
+ *
+ *    \param rw SDL_RWops with sound data.
+ *    \param ext File extension normally associated with a data format.
+ *               Can usually be NULL.
+ *    \param desired Format to convert sound data into. Can usually be NULL,
+ *                   if you don't need conversion.
+ *    \param bufferSize Size, in bytes, to allocate for the decoding buffer.
+ *   \return Sound_Sample pointer, which is used as a handle to several other
+ *           SDL_sound APIs. NULL on error. If error, use
+ *           Sound_GetError() to see what went wrong.
+ *
+ * \sa Sound_NewSampleFromFile
+ * \sa Sound_SetBufferSize
+ * \sa Sound_Decode
+ * \sa Sound_DecodeAll
+ * \sa Sound_Seek
+ * \sa Sound_Rewind
+ * \sa Sound_FreeSample
+ */
+	Sound_Sample * Sound_NewSample(SDL_RWops *rw,
+								   char *ext,
+								   Sound_AudioInfo *desired,
+								   Uint32 bufferSize);
+
+/**
+ * \fn Sound_Sample *Sound_NewSampleFromFile(const char *filename, Sound_AudioInfo *desired, Uint32 bufferSize)
+ * \brief Start decoding a new sound sample from a file on disk.
+ *
+ * This is identical to Sound_NewSample(), but it creates an SDL_RWops for you
+ *  from the file located in (filename). Note that (filename) is specified in
+ *  platform-dependent notation. ("C:\\music\\mysong.mp3" on windows, and
+ *  "/home/icculus/music/mysong.mp3" or whatever on Unix, etc.)
+ * Sound_NewSample()'s "ext" parameter is gleaned from the contents of
+ *  (filename).
+ *
+ *    \param filename file containing sound data.
+ *    \param desired Format to convert sound data into. Can usually be NULL,
+ *                   if you don't need conversion.
+ *    \param bufferSize size, in bytes, of initial read buffer.
+ *   \return Sound_Sample pointer, which is used as a handle to several other
+ *           SDL_sound APIs. NULL on error. If error, use
+ *           Sound_GetError() to see what went wrong.
+ *
+ * \sa Sound_NewSample
+ * \sa Sound_SetBufferSize
+ * \sa Sound_Decode
+ * \sa Sound_DecodeAll
+ * \sa Sound_Seek
+ * \sa Sound_Rewind
+ * \sa Sound_FreeSample
+ */
+	Sound_Sample * Sound_NewSampleFromFile(char *fname,
+										   Sound_AudioInfo *desired,
+										   Uint32 bufferSize);
+
+/**
+ * \fn void Sound_FreeSample(Sound_Sample *sample)
+ * \brief Dispose of a Sound_Sample.
+ *
+ * This will also close/dispose of the SDL_RWops that was used at creation
+ *  time, so there's no need to keep a reference to that around.
+ * The Sound_Sample pointer is invalid after this call, and will almost
+ *  certainly result in a crash if you attempt to keep using it.
+ *
+ *    \param sample The Sound_Sample to delete.
+ *
+ * \sa Sound_NewSample
+ * \sa Sound_NewSampleFromFile
+ */
+	void Sound_FreeSample(Sound_Sample *sample);
+
+
+/**
+ * \fn int Sound_SetBufferSize(Sound_Sample *sample, Uint32 new_size)
+ * \brief Change the current buffer size for a sample.
+ *
+ * If the buffer size could be changed, then the sample->buffer and
+ *  sample->buffer_size fields will reflect that. If they could not be
+ *  changed, then your original sample state is preserved. If the buffer is
+ *  shrinking, the data at the end of buffer is truncated. If the buffer is
+ *  growing, the contents of the new space at the end is undefined until you
+ *  decode more into it or initialize it yourself.
+ *
+ * The buffer size specified must be a multiple of the size of a single
+ *  sample point. So, if you want 16-bit, stereo samples, then your sample
+ *  point size is (2 channels * 16 bits), or 32 bits per sample, which is four
+ *  bytes. In such a case, you could specify 128 or 132 bytes for a buffer,
+ *  but not 129, 130, or 131 (although in reality, you'll want to specify a
+ *  MUCH larger buffer).
+ *
+ *    \param sample The Sound_Sample whose buffer to modify.
+ *    \param new_size The desired size, in bytes, of the new buffer.
+ *   \return non-zero if buffer size changed, zero on failure.
+ *
+ * \sa Sound_Decode
+ * \sa Sound_DecodeAll
+ */
+	int Sound_SetBufferSize(Sound_Sample *sample,
+							   Uint32 new_size);
+
+
+/**
+ * \fn Uint32 Sound_Decode(Sound_Sample *sample)
+ * \brief Decode more of the sound data in a Sound_Sample.
+ *
+ * It will decode at most sample->buffer_size bytes into sample->buffer in the
+ *  desired format, and return the number of decoded bytes.
+ * If sample->buffer_size bytes could not be decoded, then please refer to
+ *  sample->flags to determine if this was an end-of-stream or error condition.
+ *
+ *    \param sample Do more decoding to this Sound_Sample.
+ *   \return number of bytes decoded into sample->buffer. If it is less than
+ *           sample->buffer_size, then you should check sample->flags to see
+ *           what the current state of the sample is (EOF, error, read again).
+ *
+ * \sa Sound_DecodeAll
+ * \sa Sound_SetBufferSize
+ * \sa Sound_Seek
+ * \sa Sound_Rewind
+ */
+	Uint32 Sound_Decode(Sound_Sample *sample);
+
+
+/**
+ * \fn Uint32 Sound_DecodeAll(Sound_Sample *sample)
+ * \brief Decode the remainder of the sound data in a Sound_Sample.
+ *
+ * This will dynamically allocate memory for the ENTIRE remaining sample.
+ *  sample->buffer_size and sample->buffer will be updated to reflect the
+ *  new buffer. Please refer to sample->flags to determine if the decoding
+ *  finished due to an End-of-stream or error condition.
+ *
+ * Be aware that sound data can take a large amount of memory, and that
+ *  this function may block for quite awhile while processing. Also note
+ *  that a streaming source (for example, from a SDL_RWops that is getting
+ *  fed from an Internet radio feed that doesn't end) may fill all available
+ *  memory before giving up...be sure to use this on finite sound sources
+ *  only!
+ *
+ * When decoding the sample in its entirety, the work is done one buffer at a
+ *  time. That is, sound is decoded in sample->buffer_size blocks, and
+ *  appended to a continually-growing buffer until the decoding completes.
+ *  That means that this function will need enough RAM to hold approximately
+ *  sample->buffer_size bytes plus the complete decoded sample at most. The
+ *  larger your buffer size, the less overhead this function needs, but beware
+ *  the possibility of paging to disk. Best to make this user-configurable if
+ *  the sample isn't specific and small.
+ *
+ *    \param sample Do all decoding for this Sound_Sample.
+ *   \return number of bytes decoded into sample->buffer. You should check
+ *           sample->flags to see what the current state of the sample is
+ *           (EOF, error, read again).
+ *
+ * \sa Sound_Decode
+ * \sa Sound_SetBufferSize
+ */
+	Uint32 Sound_DecodeAll(Sound_Sample *sample);
+
+
+/**
+ * \fn int Sound_Rewind(Sound_Sample *sample)
+ * \brief Rewind a sample to the start.
+ *
+ * Restart a sample at the start of its waveform data, as if newly
+ *  created with Sound_NewSample(). If successful, the next call to
+ *  Sound_Decode[All]() will give audio data from the earliest point
+ *  in the stream.
+ *
+ * Beware that this function will fail if the SDL_RWops that feeds the
+ *  decoder can not be rewound via it's seek method, but this can
+ *  theoretically be avoided by wrapping it in some sort of buffering
+ *  SDL_RWops.
+ *
+ * This function should ONLY fail if the RWops is not seekable, or
+ *  SDL_sound is not initialized. Both can be controlled by the application,
+ *  and thus, it is up to the developer's paranoia to dictate whether this
+ *  function's return value need be checked at all.
+ *
+ * If this function fails, the state of the sample is undefined, but it
+ *  is still safe to call Sound_FreeSample() to dispose of it.
+ *
+ * On success, ERROR, EOF, and EAGAIN are cleared from sample->flags. The
+ *  ERROR flag is set on error.
+ *
+ *    \param sample The Sound_Sample to rewind.
+ *   \return nonzero on success, zero on error. Specifics of the
+ *           error can be gleaned from Sound_GetError().
+ *
+ * \sa Sound_Seek
+ */
+	int Sound_Rewind(Sound_Sample *sample);
+
+
+/**
+ * \fn int Sound_Seek(Sound_Sample *sample, Uint32 ms)
+ * \brief Seek to a different point in a sample.
+ *
+ * Reposition a sample's stream. If successful, the next call to
+ *  Sound_Decode[All]() will give audio data from the offset you
+ *  specified.
+ *
+ * The offset is specified in milliseconds from the start of the
+ *  sample.
+ *
+ * Beware that this function can fail for several reasons. If the
+ *  SDL_RWops that feeds the decoder can not seek, this call will almost
+ *  certainly fail, but this can theoretically be avoided by wrapping it
+ *  in some sort of buffering SDL_RWops. Some decoders can never seek,
+ *  others can only seek with certain files. The decoders will set a flag
+ *  in the sample at creation time to help you determine this.
+ *
+ * You should check sample->flags & SOUND_SAMPLEFLAG_CANSEEK
+ *  before attempting. Sound_Seek() reports failure immediately if this
+ *  flag isn't set. This function can still fail for other reasons if the
+ *  flag is set.
+ *
+ * This function can be emulated in the application with Sound_Rewind()
+ *  and predecoding a specific amount of the sample, but this can be
+ *  extremely inefficient. Sound_Seek() accelerates the seek on a
+ *  with decoder-specific code.
+ *
+ * If this function fails, the sample should continue to function as if
+ *  this call was never made. If there was an unrecoverable error,
+ *  sample->flags & SOUND_SAMPLEFLAG_ERROR will be set, which you regular
+ *  decoding loop can pick up.
+ *
+ * On success, ERROR, EOF, and EAGAIN are cleared from sample->flags.
+ *
+ *    \param sample The Sound_Sample to seek.
+ *    \param ms The new position, in milliseconds from start of sample.
+ *   \return nonzero on success, zero on error. Specifics of the
+ *           error can be gleaned from Sound_GetError().
+ *
+ * \sa Sound_Rewind
+ */
+	int Sound_Seek(Sound_Sample *sample, Uint32 ms);
+
+}
+
+
+/* end of SDL_sound.h ... */
+
diff -Naur psyno/src/shot.d psyno-gentoo/src/shot.d
--- psyno/src/shot.d	2004-11-26 07:57:40.000000000 +0100
+++ psyno-gentoo/src/shot.d	2007-09-23 12:10:16.000000000 +0200
@@ -3,7 +3,6 @@
 private import SDL;
 
 private import charactor;
-private import log;
 private import mymath;
 private import mygl;
 private import objspecs;
diff -Naur psyno/src/sino.d psyno-gentoo/src/sino.d
--- psyno/src/sino.d	2004-11-28 04:12:17.000000000 +0100
+++ psyno-gentoo/src/sino.d	2007-09-23 12:41:35.000000000 +0200
@@ -12,7 +12,6 @@
 private import openglu;
 
 private import rc;
-private import log;
 private import fpstimer;
 private import scene;
 private import scene_select;
@@ -33,24 +32,24 @@
 public:
     this(char args[][]) {
         obj_ = this;
-        Log.info("init");
+ //      Log.info("init");
         initResource(args);
         initMisc();
         initSDL();
         initGL();
-        Log.info("init done");
+ //       Log.info("init done");
     }
 
     ~this() {
-        Log.info("quit");
+//        Log.info("quit");
         delete sound_;
         SDLNet_Quit();
         SDL_Quit();
-        Log.info("quit done");
+  //      Log.info("quit done");
     }
 
     void initResource(char args[][]) {
-        Log.info("init resource");
+  //      Log.info("init resource");
 
         rc_ = new Rc();
         rc().addResourceFile();
@@ -58,7 +57,7 @@
     }
 
     void initMisc() {
-        Log.info("init misc");
+  //      Log.info("init misc");
 
         rand_seed(getUTCtime(), 0);
 
@@ -79,20 +78,20 @@
     }
 
     void initSDL() {
-        Log.info("init SDL");
+//        Log.info("init SDL");
 
         int ret = SDL_Init(SDL_INIT_VIDEO|SDL_INIT_NOPARACHUTE);
-        if (ret != 0) Log.errorSDL("cannot init SDL");
+//        if (ret != 0) Log.errorSDL("cannot init SDL");
 
         ret = SDL_InitSubSystem(SDL_INIT_JOYSTICK);
         if (ret != 0) {
-            Log.warnSDL("cannot init joystick");
+//            Log.warnSDL("cannot init joystick");
         }
 
         useAudio_ = true;
         ret = SDL_InitSubSystem(SDL_INIT_AUDIO);
         if (ret != 0) {
-            Log.warnSDL("cannot init audio");
+//            Log.warnSDL("cannot init audio");
             useAudio_ = false;
         }
 
@@ -105,14 +104,14 @@
 
         if (bpp == -1) {
             bpp = info.vfmt.BitsPerPixel;
-            Log.info("using the \"best\" bpp: " ~ tostr(bpp));
+//            Log.info("using the \"best\" bpp: " ~ tostr(bpp));
         }
         else if (bpp == 0) {
             bpp = info.vfmt.BitsPerPixel;
-            Log.info("using current bpp");
+//            Log.info("using current bpp");
         }
         else {
-            Log.info("using user set bpp: " ~ tostr(bpp));
+//            Log.info("using user set bpp: " ~ tostr(bpp));
         }
 
         SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5 );  
@@ -130,19 +129,19 @@
             flags |= SDL_FULLSCREEN;
         }
 
-        Log.info("set video mode " ~
-                 "size = " ~ tostr(screenWidth_) ~
-                 "x" ~ tostr(screenHeight_) ~
-                 ", bpp = " ~ tostr(bpp) ~
-                 ", flags = " ~ tostr(flags));
+//        Log.info("set video mode " ~
+//                 "size = " ~ tostr(screenWidth_) ~
+//                 "x" ~ tostr(screenHeight_) ~
+//                 ", bpp = " ~ tostr(bpp) ~
+//                 ", flags = " ~ tostr(flags));
         if (SDL_SetVideoMode(screenWidth_, screenHeight_,
                              bpp, flags) == null)
         {
-            Log.errorSDL("cannot create screen");
+//            Log.errorSDL("cannot create screen");
         }
 
         info = SDL_GetVideoInfo();
-        Log.info("set bpp: " ~ tostr(cast(int)info.vfmt.BitsPerPixel));
+//        Log.info("set bpp: " ~ tostr(cast(int)info.vfmt.BitsPerPixel));
 
         Pad_Init();
         Pad_LoadDefault("save/key.conf");
@@ -180,21 +179,21 @@
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 
         if (glGetError()) {
-            Log.error(tostr(gluErrorString(glGetError())));
+//            Log.error(tostr(gluErrorString(glGetError())));
         }
 
         initLetter();
     }
 
     void run() {
-        Log.info("run");
+//        Log.info("run");
 
         Scene.init();
         scene_ = new SceneSelect();
 
         timer_.start();
 
-        while (scene_ !== null) {
+        while (scene_ !is null) {
             Pad_Pump(PAD_PUMP_EVERYTHING);
 
             scene_.run();
@@ -225,7 +224,7 @@
             endCheck();
         }
 
-        Log.info("run done");
+//        Log.info("run done");
     }
 
     void drawSystemInfo() {
@@ -258,7 +257,7 @@
 
     void endCheck() {
         if (Pad_GetButtonPressed(PAD_END_BUTTON)) {
-            Log.info("quit event catched");
+//            Log.info("quit event catched");
             quit();
         }
         if (Pad_GetButtonPushed(PAD_C_BUTTON)) {
@@ -274,12 +273,12 @@
     }
 
     void quit() {
-        Log.info("FPS: " ~ std.string.toString(timer_.getTrueFps()));
+//        Log.info("FPS: " ~ std.string.toString(timer_.getTrueFps()));
         scene_ = null;
     }
 
     void end() {
-        Log.info("FPS: " ~ std.string.toString(timer_.getTrueFps()));
+//        Log.info("FPS: " ~ std.string.toString(timer_.getTrueFps()));
         scene_ = scene_.getNext();
     }
 
@@ -317,11 +316,11 @@
 
 
 extern(C) int doit(char args[][]) {
-    Log.init();
+//    Log.init();
     Sino c = new Sino(args);
     c.run();
     delete c;
-    Log.quit();
+//    Log.quit();
 
     return 0;
 }
diff -Naur psyno/src/sound.d psyno-gentoo/src/sound.d
--- psyno/src/sound.d	2004-11-25 11:29:26.000000000 +0100
+++ psyno-gentoo/src/sound.d	2007-09-23 12:42:38.000000000 +0200
@@ -1,10 +1,9 @@
 private import std.string;
-
+private import SDL;
 private import SDL_mixer;
 
 private import sino;
 private import rc;
-private import log;
 private import sound_phase;
 
 enum Se {
@@ -63,7 +62,7 @@
 
         if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0) {
             noSound_ = 1;
-            Log.warnSDL("Unable to initialize SDL_AUDIO");
+//            Log.warnSDL("Unable to initialize SDL_AUDIO");
             return;
         }
 
@@ -74,7 +73,7 @@
         if (Mix_OpenAudio(audio_rate, audio_format,
                           audio_channels, audio_buffers) < 0) {
             noSound_ = 1;
-            Log.warnSDL("Couldn't open audio");
+//            Log.warnSDL("Couldn't open audio");
             return;
         }
         Mix_QuerySpec(&audio_rate, &audio_format, &audio_channels);
@@ -130,7 +129,7 @@
         music_ = Mix_LoadMUS(toStringz(fileName));
         if (!music_) {
 //            noSound_ = true;
-            Log.warnSDL("Couldn't load: " ~ fileName);
+//            Log.warnSDL("Couldn't load: " ~ fileName);
         }
     }
   
@@ -183,7 +182,7 @@
             char[] seFileName = chunksDir ~ Sino.rc.get(seName);
             chunk_[i] = Mix_LoadWAV(toStringz(seFileName));
             if (!chunk_[i]) {
-                Log.warnSDL("Couldn't load: " ~ seFileName);
+//                Log.warnSDL("Couldn't load: " ~ seFileName);
             }
         }
     }
diff -Naur psyno/src/texture.d psyno-gentoo/src/texture.d
--- psyno/src/texture.d	2004-11-16 16:21:14.000000000 +0100
+++ psyno-gentoo/src/texture.d	2007-09-23 12:43:17.000000000 +0200
@@ -2,9 +2,8 @@
 private import opengl;
 private import std.c.stdio;
 private import std.c.stdlib;
-private import std.string;
+private import std.c.string;
 
-private import log;
 
 // rough texture manager
 enum TextureID {
@@ -28,7 +27,7 @@
     }
 
     this(char[] filename) {
-        Log.info(filename ~ ": loading texture");
+//        Log.info(filename ~ ": loading texture");
 
         SDL_Surface* surf = SDL_LoadBMP(filename);
         SDL_SetColorKey(surf, SDL_SRCCOLORKEY, 0);
diff -Naur psyno/src/thunder.d psyno-gentoo/src/thunder.d
--- psyno/src/thunder.d	2004-11-13 19:13:12.000000000 +0100
+++ psyno-gentoo/src/thunder.d	2007-09-23 12:12:42.000000000 +0200
@@ -33,7 +33,7 @@
         x_ += sx_;
         y_ += sy_;
 
-        if (moveFunc_ === null) {
+        if (moveFunc_ is null) {
             float rs() { return rnd(15)-7; }
             sx_ += rs;
             sy_ += rs;
diff -Naur psyno/src/winmain.d psyno-gentoo/src/winmain.d
--- psyno/src/winmain.d	2004-11-13 19:13:12.000000000 +0100
+++ psyno-gentoo/src/winmain.d	2007-09-23 12:43:45.000000000 +0200
@@ -17,13 +17,13 @@
 {
     int result;
 
-    gc_init();          // ガベージコレクタ初期化
-    _minit();           // モジュールコンストラクタテーブル初期化
+    gc_init();          //
+    _minit();           // 
     
     try
     {
-        _moduleCtor();      // モジュールコンストラクタ呼び出し
-        _moduleUnitTests(); // 単体テスト実行 (オプション)
+        _moduleCtor();      //
+        _moduleUnitTests(); // 
 
         char[] arg = std.string.toString(lpCmdLine);
         char exe[4096];
@@ -32,17 +32,17 @@
         args ~= std.string.toString(exe);
         args ~= split(arg);
 
-        result = doit(args);    // ここにユーザーコードを置きます
+        result = doit(args);    //
     }
     
-    catch (Object o)        // キャッチされていない例外を全てキャッチ
+    catch (Object o)        // 
     {
         MessageBoxA(null, cast(char *)o.toString(), "Error",
                     MB_OK | MB_ICONEXCLAMATION);
         result = 0;     // failed
     }
    
-    gc_term();          // ファイナライザの実行、ガベージコレクタ終了
+    gc_term();          //
     return result;
 }
 }
