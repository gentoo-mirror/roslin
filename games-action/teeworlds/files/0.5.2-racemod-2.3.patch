Index: src/engine/e_if_server.h
===================================================================
--- src/engine/e_if_server.h	(Revision 2005)
+++ src/engine/e_if_server.h	(Arbeitskopie)
@@ -137,4 +137,7 @@
 
 int server_ban_add(NETADDR addr, int seconds);
 int server_ban_remove(NETADDR addr);
+
+void server_getip(int client_id, char *buf);
+
 #endif
Index: src/engine/server/es_server.c
===================================================================
--- src/engine/server/es_server.c	(Revision 2005)
+++ src/engine/server/es_server.c	(Arbeitskopie)
@@ -671,6 +671,13 @@
 				return;
 			}
 			
+			/*slot*/
+			if(cid >= netserver_max_clients(net)-config.sv_reserved_slots && config.sv_reserved_slots_pass[0] != 0 && strcmp(config.sv_reserved_slots_pass, password) != 0)
+			{
+				netserver_drop(net, cid, "server is full");
+				return;
+			}
+			
 			clients[cid].state = SRVCLIENT_STATE_CONNECTING;
 			server_send_map(cid);
 		}
@@ -882,6 +889,7 @@
 	char buf[128];
 
 	/* count the players */	
+	int max_pl;
 	int player_count = 0;
 	int i;
 	for(i = 0; i < MAX_CLIENTS; i++)
@@ -890,6 +898,9 @@
 			player_count++;
 	}
 	
+	max_pl = netserver_max_clients(net)-config.sv_reserved_slots;
+	max_pl = (max_pl<player_count)?player_count:max_pl;
+	
 	packer_reset(&p);
 
 	if(token >= 0)
@@ -924,7 +935,7 @@
 	packer_add_string(&p, buf, 4);
 	
 	str_format(buf, sizeof(buf), "%d", player_count); packer_add_string(&p, buf, 3);  /* num players */
-	str_format(buf, sizeof(buf), "%d", netserver_max_clients(net)); packer_add_string(&p, buf, 3); /* max players */
+	str_format(buf, sizeof(buf), "%d", max_pl); packer_add_string(&p, buf, 3); /* max players */
 
 	for(i = 0; i < MAX_CLIENTS; i++)
 	{
@@ -1376,3 +1387,11 @@
 	return 0;
 }
 
+void server_getip(int client_id, char *buf)
+{
+	NETADDR addr;
+	netserver_client_addr(net, client_id, &addr);
+	if(client_id < 0 || client_id > MAX_CLIENTS || clients[client_id].state < SRVCLIENT_STATE_READY)
+		return;
+	sprintf(buf, "%d.%d.%d.%d", addr.ip[0], addr.ip[1], addr.ip[2], addr.ip[3]);
+}
Index: src/game/collision.cpp
===================================================================
--- src/game/collision.cpp	(Revision 2005)
+++ src/game/collision.cpp	(Arbeitskopie)
@@ -12,6 +12,10 @@
 static TILE *tiles;
 static int width = 0;
 static int height = 0;
+//race
+static int *dest[42];
+static int len[42];
+static int tele[42];
 
 int col_width() { return width; }
 int col_height() { return height; }
@@ -22,6 +26,30 @@
 	height = layers_game_layer()->height;
 	tiles = (TILE *)map_get_data(layers_game_layer()->data);
 	
+	// race
+	mem_zero(&len, sizeof(len));
+	mem_zero(&tele, sizeof(tele));
+	for(int i = width*height-1; i >= 0; i--)
+	{
+		if(tiles[i].index > 34 && tiles[i].index < 85)
+		{
+			if(tiles[i].index&1)
+				len[tiles[i].index >> 1]++;
+			else if(!(tiles[i].index&1))
+				tele[(tiles[i].index-1) >> 1]++;
+		}
+	}
+	for(int i = 0; i < 42; i++)
+	{
+		dest[i] = new int[len[i]];
+		len[i] = 0;
+	}
+	for(int i = width*height-1; i >= 0; i--)
+	{
+		if(tiles[i].index&1 && tiles[i].index > 34 && tiles[i].index < 85)
+			dest[tiles[i].index>>1][len[tiles[i].index>>1]++] = i;
+	}
+
 	for(int i = 0; i < width*height; i++)
 	{
 		int index = tiles[i].index;
@@ -36,7 +64,7 @@
 		else if(index == TILE_NOHOOK)
 			tiles[i].index = COLFLAG_SOLID|COLFLAG_NOHOOK;
 		else
-			tiles[i].index = 0;
+			tiles[i].index = index;
 	}
 				
 	return 1;
@@ -50,7 +78,10 @@
 	
 	if(tiles[ny*width+nx].index > 128)
 		return 0;
-	return tiles[ny*width+nx].index;
+	if(tiles[ny*width+nx].index == COLFLAG_SOLID || tiles[ny*width+nx].index == (COLFLAG_SOLID|COLFLAG_NOHOOK) || tiles[ny*width+nx].index == COLFLAG_DEATH)
+		return tiles[ny*width+nx].index;
+	else
+		return 0;
 }
 
 int col_is_solid(int x, int y)
@@ -58,7 +89,56 @@
 	return col_get(x,y)&COLFLAG_SOLID;
 }
 
+//race
+int col_is_teleport(int x, int y)
+{
+	int nx = x/32;
+	int ny = y/32;
+	if(y < 0 || nx < 0 || nx >= width || ny >= height)
+		return 0;
+	
+	int z = tiles[ny*width+nx].index-1;
+	if(z > 34 && z < 85 && z&1)
+		return z>>1;
+	return 0;
+}
 
+int col_is_checkpoint(int x, int y)
+{
+	int nx = x/32;
+	int ny = y/32;
+	if(y < 0 || nx < 0 || nx >= width || ny >= height)
+		return 0;
+	
+	int z = tiles[ny*width+nx].index;
+	if(z > 34 && z < 85 && z&1 && tele[z>>1] <= 0)
+		return z>>1;
+	return 0;
+}
+
+int col_get_index(int x, int y)
+{
+	int nx = x/32;
+	int ny = y/32;
+	if(y<0 || nx < 0 || nx >= width || ny >= height)
+		return 0;
+	
+	return tiles[ny*width+nx].index;
+}
+
+vec2 teleport(int z)
+{
+	if(len[z] > 0)
+	{
+		int r = rand()%len[z];
+		int x = (dest[z][r]%width)<<5;
+		int y = (dest[z][r]/width)<<5;
+		return vec2((float)x+16.0, (float)y+16.0);
+	}
+	else
+		return vec2(0,0);
+}
+
 // TODO: rewrite this smarter!
 int col_intersect_line(vec2 pos0, vec2 pos1, vec2 *out_collision, vec2 *out_before_collision)
 {
Index: src/game/collision.hpp
===================================================================
--- src/game/collision.hpp	(Revision 2005)
+++ src/game/collision.hpp	(Arbeitskopie)
@@ -18,4 +18,9 @@
 int col_height();
 int col_intersect_line(vec2 pos0, vec2 pos1, vec2 *out_collision, vec2 *out_before_collision);
 
+//race
+int col_is_teleport(int x, int y);
+int col_is_checkpoint(int x, int y);
+int col_get_index(int x, int y);
+vec2 teleport(int z);
 #endif
Index: src/game/mapitems.hpp
===================================================================
--- src/game/mapitems.hpp	(Revision 2005)
+++ src/game/mapitems.hpp	(Arbeitskopie)
@@ -45,6 +45,12 @@
 	TILE_SOLID,
 	TILE_DEATH,
 	TILE_NOHOOK,
+	TILE_BOOSTL=29,
+	TILE_BOOSTR,
+	TILE_BOOST,
+	TILE_JUMPER,
+	TILE_BEGIN,
+	TILE_END,
 	
 	TILEFLAG_VFLIP=1,
 	TILEFLAG_HFLIP=2,
Index: src/game/server/entities/character.cpp
===================================================================
--- src/game/server/entities/character.cpp	(Revision 2005)
+++ src/game/server/entities/character.cpp	(Arbeitskopie)
@@ -1,8 +1,10 @@
 #include <new>
+#include "../gamemodes/race.hpp"
 #include <engine/e_server_interface.h>
 #include <engine/e_config.h>
 #include <game/server/gamecontext.hpp>
 #include <game/mapitems.hpp>
+#include <string.h>
 
 #include "character.hpp"
 #include "laser.hpp"
@@ -52,10 +54,16 @@
 	player_state = PLAYERSTATE_UNKNOWN;
 	emote_stop = -1;
 	last_action = -1;
-	active_weapon = WEAPON_GUN;
+	if(!game.controller->is_race())
+		active_weapon = WEAPON_GUN;
+	else
+		active_weapon = WEAPON_HAMMER;
+
 	last_weapon = WEAPON_HAMMER;
 	queued_weapon = -1;
 	
+	race_state = RACE_NONE;
+	
 	//clear();
 	this->player = player;
 	this->pos = pos;
@@ -293,7 +301,10 @@
 			
 			CHARACTER *ents[64];
 			int hits = 0;
-			int num = game.world.find_entities(pos+direction*phys_size*0.75f, phys_size*0.5f, (ENTITY**)ents, 64, NETOBJTYPE_CHARACTER);
+			int num = -1;
+			if(!game.controller->is_race())
+				num = game.world.find_entities(pos+direction*phys_size*0.75f, phys_size*0.5f, (ENTITY**)ents, 64, NETOBJTYPE_CHARACTER);
+ 
 
 			for (int i = 0; i < num; i++)
 			{
@@ -427,7 +438,7 @@
 		
 	}
 
-	if(weapons[active_weapon].ammo > 0) // -1 == unlimited
+	if(weapons[active_weapon].ammo > 0 && (!game.controller->is_race() || !config.sv_infinite_ammo)) // -1 == unlimited
 		weapons[active_weapon].ammo--;
 	attack_tick = server_tick();
 	if(!reload_timer)
@@ -543,7 +554,117 @@
 	//core.jumped = jumped;
 	core.input = input;
 	core.tick(true);
+
+	//race
+	char buftime[128];
+	float time = (float)(server_tick()-starttime)/((float)server_tickspeed());
 	
+	int z = col_is_checkpoint(pos.x, pos.y);
+	if(z && race_state == RACE_STARTED)
+	{
+		cp_active = z;
+		cp_current[z] = time;
+		cp_tick = server_tick() + server_tickspeed()*2;
+	}
+	if(race_state == RACE_STARTED && server_tick()-refreshtime >= server_tickspeed())
+	{
+		int int_time = (int)time;
+		str_format(buftime, sizeof(buftime), "Current time: %d min %d sec", int_time/60, int_time%60);
+		
+		if(cp_active && cp_tick > server_tick())
+		{
+			PLAYER_SCORE *pscore = ((GAMECONTROLLER_RACE*)game.controller)->score.search_score(player->client_id, 0, 0);
+			if(pscore && pscore->cp_time[cp_active] != 0)
+			{
+				char tmp[128];
+				float diff = cp_current[cp_active] - pscore->cp_time[cp_active];
+				str_format(tmp, sizeof(tmp), "\nCheckpoint | Diff : %s%5.3f", (diff >= 0)?"+":"", diff);
+				strcat(buftime, tmp);
+			}
+		}
+		
+		game.send_broadcast(buftime, player->client_id);
+		refreshtime = server_tick();
+	}
+	
+	if(config.sv_regen > 0 && (server_tick()%config.sv_regen) == 0 && game.controller->is_race())
+	{
+		if(health < 10) 
+			health++;
+		else if(armor < 10)
+			armor++;
+	}
+	
+	if(col_get_index(pos.x, pos.y) == TILE_BEGIN && game.controller->is_race() && (!weapons[WEAPON_GRENADE].got || race_state == RACE_NONE))
+	{
+		starttime = server_tick();
+		refreshtime = server_tick();
+		race_state = RACE_STARTED;
+	}
+	else if(col_get_index(pos.x, pos.y) == TILE_END && race_state == RACE_STARTED)
+	{
+		char buf[128];
+		str_format(buf, sizeof(buf), "%s finished in: %d minute(s) %5.3f second(s)", server_clientname(player->client_id), (int)time/60, time-((int)time/60*60));
+		game.send_chat(-1,GAMECONTEXT::CHAT_ALL, buf);
+		
+		PLAYER_SCORE *pscore = ((GAMECONTROLLER_RACE*)game.controller)->score.search_score(player->client_id, 0, 0);
+		if(pscore && time - pscore->score < 0)
+		{
+			str_format(buf, sizeof(buf), "New record: %5.3f second(s) better", time - pscore->score);
+			game.send_chat(-1, GAMECONTEXT::CHAT_ALL, buf);
+		}
+		
+		int ttime = 0-(int)time;
+		race_state = RACE_FINISHED;
+		
+		if(player->score < ttime)
+			player->score = ttime;
+		if(strncmp(server_clientname(player->client_id), "nameless tee", 12) != 0)
+			((GAMECONTROLLER_RACE*)game.controller)->score.parsePlayer(player->client_id, (float)time, cp_current);
+	}
+	else if(col_get_index(core.pos.x, core.pos.y) == TILE_BOOST && game.controller->is_race())
+	{
+		if(core.vel.x >= 0)
+			core.vel.x = core.vel.x*(((float)config.sv_speedup_mult)/10.0)+config.sv_speedup_add;
+		else 
+			core.vel.x = core.vel.x*(((float)config.sv_speedup_mult)/10.0)-config.sv_speedup_add;
+	}
+	else if(col_get_index(core.pos.x, core.pos.y) == TILE_BOOSTR && game.controller->is_race())
+	{
+		if(core.vel.x >= 0)
+			core.vel.x = core.vel.x*(((float)config.sv_speedup_mult)/10.0)+config.sv_speedup_add;
+		else 
+			core.vel.x = config.sv_speedup_add;
+	}
+	else if(col_get_index(core.pos.x, core.pos.y) == TILE_BOOSTL && game.controller->is_race())
+	{
+		if(core.vel.x <= 0)
+			core.vel.x = core.vel.x*(((float)config.sv_speedup_mult)/10.0)-config.sv_speedup_add;
+		else
+			core.vel.x = 0-config.sv_speedup_add;
+	}
+ 	else if(col_get_index(core.pos.x, core.pos.y) == TILE_JUMPER && game.controller->is_race())
+		core.vel.y -= config.sv_jumper_add;
+	
+	z = col_is_teleport(pos.x, pos.y);
+	if(config.sv_teleport && z && game.controller->is_race())
+	{
+		core.hooked_player = -1;
+		core.hook_state = HOOK_RETRACTED;
+		core.triggered_events |= COREEVENT_HOOK_RETRACT;
+		core.hook_state = HOOK_RETRACTED;
+		core.pos = teleport(z);
+		core.hook_pos = core.pos;
+		if(config.sv_strip)
+		{
+			active_weapon = WEAPON_HAMMER;
+			last_weapon = WEAPON_HAMMER;
+			weapons[0].got = true;
+			for(int i = 1; i < 5; i++)
+				weapons[i].got = false;
+		}
+	}
+	
 	float phys_size = 28.0f;
 	// handle death-tiles
 	if(col_get((int)(pos.x+phys_size/2), (int)(pos.y-phys_size/2))&COLFLAG_DEATH ||
@@ -696,7 +817,8 @@
 
 bool CHARACTER::take_damage(vec2 force, int dmg, int from, int weapon)
 {
-	core.vel += force;
+	if(!game.controller->is_race() || (game.controller->is_race() && from == player->client_id))
+		core.vel += force;
 	
 	if(game.controller->is_friendly_fire(player->client_id, from) && !config.sv_teamdamage)
 		return false;
@@ -705,6 +827,9 @@
 	if(from == player->client_id)
 		dmg = max(1, dmg/2);
 
+	if(((from == player->client_id && !config.sv_rocket_jump_damage) || from != player->client_id) && game.controller->is_race())
+		dmg = 0;
+
 	damage_taken++;
 
 	// create healthmod indicator
Index: src/game/server/entities/character.hpp
===================================================================
--- src/game/server/entities/character.hpp	(Revision 2005)
+++ src/game/server/entities/character.hpp	(Arbeitskopie)
@@ -16,6 +16,13 @@
 	WEAPON_WORLD = -1, // death tiles etc
 };
 
+enum
+{
+	RACE_NONE = 0,
+	RACE_STARTED,
+	RACE_FINISHED,
+};
+
 class CHARACTER : public ENTITY
 {
 	MACRO_ALLOC_POOL_ID()
@@ -83,6 +90,16 @@
 	//int score;
 	int team;
 	int player_state; // if the client is chatting, accessing a menu or so
+	
+	// race var
+	int starttime;
+	int refreshtime;
+	int race_state;
+	
+	// checkpoints
+	int cp_tick;
+	int cp_active;
+	float cp_current[42];
 
 	// the player core for the physics	
 	CHARACTER_CORE core;
Index: src/game/server/entities/pickup.cpp
===================================================================
--- src/game/server/entities/pickup.cpp	(Revision 2005)
+++ src/game/server/entities/pickup.cpp	(Arbeitskopie)
@@ -1,4 +1,5 @@
 #include <engine/e_server_interface.h>
+#include <engine/e_config.h>
 #include <game/generated/g_protocol.hpp>
 #include <game/server/gamecontext.hpp>
 #include "pickup.hpp"
@@ -126,7 +127,8 @@
 		{
 			dbg_msg("game", "pickup player='%d:%s' item=%d/%d",
 				chr->player->client_id, server_clientname(chr->player->client_id), type, subtype);
-			spawntick = server_tick() + server_tickspeed() * respawntime;
+			int pickup_respawn = (game.controller->is_race())?config.sv_pickup_respawn:1;
+			spawntick = server_tick() + server_tickspeed() * respawntime * pickup_respawn;
 		}
 	}
 }
Index: src/game/server/entities/projectile.cpp
===================================================================
--- src/game/server/entities/projectile.cpp	(Revision 2005)
+++ src/game/server/entities/projectile.cpp	(Arbeitskopie)
@@ -1,4 +1,5 @@
 #include <engine/e_server_interface.h>
+#include <engine/e_config.h>
 #include <game/generated/g_protocol.hpp>
 #include <game/server/gamecontext.hpp>
 #include "projectile.hpp"
@@ -69,18 +70,24 @@
 	//int collide = col_check_point((int)curpos.x, (int)curpos.y);
 	CHARACTER *ownerchar = game.get_player_char(owner);
 	CHARACTER *targetchr = game.world.intersect_character(prevpos, curpos, 6.0f, curpos, ownerchar);
-	if(targetchr || collide || lifespan < 0)
+	if((targetchr && !game.controller->is_race()) || collide || lifespan < 0)
 	{
 		if(lifespan >= 0 || weapon == WEAPON_GRENADE)
 			game.create_sound(curpos, sound_impact);
 
 		if(flags & PROJECTILE_FLAGS_EXPLODE)
 			game.create_explosion(curpos, owner, weapon, false);
-		else if(targetchr)
+		else if((targetchr && !game.controller->is_race()))
 			targetchr->take_damage(direction * max(0.001f, force), damage, owner, weapon);
 
 		game.world.destroy_entity(this);
 	}
+	int z = col_is_teleport((int)curpos.x,curpos.y);
+  	if(config.sv_teleport && z && config.sv_teleport_grenade && weapon == WEAPON_GRENADE && game.controller->is_race())
+  	{
+ 		pos = teleport(z);
+  		start_tick = server_tick();
+	}
 }
 
 void PROJECTILE::fill_info(NETOBJ_PROJECTILE *proj)
Index: src/game/server/gamecontroller.cpp
===================================================================
--- src/game/server/gamecontroller.cpp	(Revision 2005)
+++ src/game/server/gamecontroller.cpp	(Arbeitskopie)
@@ -50,11 +50,14 @@
 		if(eval->friendly_team != -1 && c->team == eval->friendly_team)
 			scoremod = 0.5f;
 			
+		if(!is_race())
+		{
 		float d = distance(pos, c->pos);
 		if(d == 0)
 			score += 1000000000.0f;
 		else
 			score += 1.0f/d;
+		}
 	}
 	
 	return score;
@@ -659,6 +662,15 @@
 	}
 }
 
+void GAMECONTROLLER::do_race_time_check()
+{
+	if(game_over_tick == -1 && !warmup)
+	{
+		if((config.sv_timelimit > 0 && (server_tick()-round_start_tick) >= config.sv_timelimit*server_tickspeed()*60))
+			endround();
+	}
+}
+
 int GAMECONTROLLER::clampteam(int team)
 {
 	if(team < 0) // spectator
@@ -669,3 +681,8 @@
 }
 
 GAMECONTROLLER *gamecontroller = 0;
+
+bool GAMECONTROLLER::is_race() const
+{
+	return false;
+}
Index: src/game/server/gamecontroller.hpp
===================================================================
--- src/game/server/gamecontroller.hpp	(Revision 2005)
+++ src/game/server/gamecontroller.hpp	(Arbeitskopie)
@@ -61,6 +61,7 @@
 
 	void do_team_score_wincheck();
 	void do_player_score_wincheck();
+	void do_race_time_check();
 	
 	void do_warmup(int seconds);
 	
@@ -131,6 +132,8 @@
 	int clampteam(int team);
 
 	virtual void post_reset();
+
+	virtual bool is_race() const;
 };
 
 #endif
Index: src/game/server/gamemodes/race.cpp
===================================================================
--- src/game/server/gamemodes/race.cpp	(Revision 0)
+++ src/game/server/gamemodes/race.cpp	(Revision 0)
@@ -0,0 +1,29 @@
+/* copyright (c) 2007 rajh, race mod stuff */
+#include <engine/e_server_interface.h>
+#include <game/mapitems.hpp>
+#include <game/server/entities/character.hpp>
+#include <game/server/player.hpp>
+#include <game/server/gamecontext.hpp>
+#include "race.hpp"
+
+GAMECONTROLLER_RACE::GAMECONTROLLER_RACE()
+{
+	gametype = "RACE";
+}
+
+int GAMECONTROLLER_RACE::on_character_death(class CHARACTER *victim, class PLAYER *killer, int weaponid)
+{
+	return 0;
+}
+
+void GAMECONTROLLER_RACE::tick()
+{
+	GAMECONTROLLER::tick();
+	
+	do_race_time_check();
+}
+
+bool GAMECONTROLLER_RACE::is_race() const
+{
+	return true;
+}
Index: src/game/server/gamemodes/race.hpp
===================================================================
--- src/game/server/gamemodes/race.hpp	(Revision 0)
+++ src/game/server/gamemodes/race.hpp	(Revision 0)
@@ -0,0 +1,21 @@
+/* copyright (c) 2007 rajh and gregwar. Score stuff */
+
+#ifndef RACE_H
+#define RACE_H
+#include <game/server/gamecontroller.hpp>
+#include <game/server/score.hpp>
+
+class GAMECONTROLLER_RACE : public GAMECONTROLLER
+{
+public:
+	
+	GAMECONTROLLER_RACE();
+	
+	SCORE score;
+	
+	virtual void tick();
+	virtual int on_character_death(class CHARACTER *victim, class PLAYER *killer, int weapon);
+	virtual bool is_race() const;
+};
+
+#endif
Index: src/game/server/hooks.cpp
===================================================================
--- src/game/server/hooks.cpp	(Revision 2005)
+++ src/game/server/hooks.cpp	(Arbeitskopie)
@@ -22,6 +22,7 @@
 #include "gamemodes/tdm.hpp"
 #include "gamemodes/ctf.hpp"
 #include "gamemodes/mod.hpp"
+#include "gamemodes/race.hpp"
 
 TUNING_PARAMS tuning;
 
@@ -111,7 +112,15 @@
 	game.players[client_id]->respawn();
 	dbg_msg("game", "join player='%d:%s'", client_id, server_clientname(client_id));
 
-
+	//race
+	if(game.controller->is_race())
+		game.players[client_id]->score = -9999;
+	else
+		game.players[client_id]->score = 0;
+	
+	if(game.controller->is_race())
+		((GAMECONTROLLER_RACE*)game.controller)->score.initPlayer(client_id);
+	
 	char buf[512];
 	str_format(buf, sizeof(buf), "%s entered and joined the %s", server_clientname(client_id), game.controller->get_team_name(game.players[client_id]->team));
 	game.send_chat(-1, GAMECONTEXT::CHAT_ALL, buf); 
@@ -191,11 +200,91 @@
 			team = GAMECONTEXT::CHAT_ALL;
 		
 		if(config.sv_spamprotection && p->last_chat+time_freq() > time_get())
-			return;
-		
-		p->last_chat = time_get();
-		
-		game.send_chat(client_id, team, msg->message);
+		{
+			if(!strcmp(msg->message, "/rank") && game.controller->is_race())
+				game.players[client_id]->last_chat = time_get()+time_freq()*10;
+			else 
+				game.players[client_id]->last_chat = time_get();
+		}
+		else
+ 		{
+			game.players[client_id]->last_chat = time_get();
+			if(!strcmp(msg->message, "/info"))
+			{
+				char buf[128];
+				str_format(buf, sizeof(buf), "Race mod %s from Rajh and Redix (say /mods). (C)Rajh (%s)", RACE_VERSION, server_clientname(client_id));
+				game.send_chat_target(client_id, buf);
+			}
+			else if(!strcmp(msg->message, "/mods"))
+			{
+				char buf[128];
+				str_format(buf, sizeof(buf), "Mod used: Homing fun (C)ShootMe | Ranking (C)GregWar (%s)", server_clientname(client_id));
+				game.send_chat_target(client_id, buf);
+			}
+			else if(!strncmp(msg->message, "/top5", 5) && game.controller->is_race())
+			{
+				const char *pt = msg->message;
+				int number = 0;
+				pt += 6;
+				while(*pt && *pt >= '0' && *pt <= '9')
+				{
+					number = number*10+(*pt-'0');
+					pt++;
+				}
+				if(number)
+					((GAMECONTROLLER_RACE*)game.controller)->score.top5_draw(client_id, number);
+				else
+					((GAMECONTROLLER_RACE*)game.controller)->score.top5_draw(client_id, 0);
+			}
+			else if(!strncmp(msg->message, "/rank", 5) && game.controller->is_race())
+			{
+				char buf[512];
+				const char *name = msg->message;
+				name += 6;
+				int pos;
+				PLAYER_SCORE *pscore;
+				
+				if(!strcmp(msg->message, "/rank"))
+					pscore = ((GAMECONTROLLER_RACE*)game.controller)->score.search_score(client_id, 1, &pos);
+				else
+					pscore = ((GAMECONTROLLER_RACE*)game.controller)->score.search_name(name, &pos, 1);
+				
+				if(pscore && pos > -1)
+				{
+					float time = pscore->score;
+					char client_name[128];
+					str_format(client_name, sizeof(client_name), " (%s)", server_clientname(client_id));
+					str_format(buf, sizeof(buf), "%d. %s Time: %d minute(s) %5.3f second(s)", pos, pscore->name, (int)time/60, time-((int)time/60*60));
+					if(strcmp(msg->message, "/rank"))
+						strcat(buf, client_name);
+					game.send_chat(-1, GAMECONTEXT::CHAT_ALL, buf);
+					game.players[client_id]->last_chat = time_get()+time_freq()*3;
+					return;
+				}
+				else if(pos == -1)
+					str_format(buf, sizeof(buf), "Several players were found.");
+				else
+					str_format(buf, sizeof(buf), "%s is not ranked", strcmp(msg->message, "/rank")?name:server_clientname(client_id));
+				
+				game.send_chat_target(client_id, buf);
+			}
+			else if(!strcmp(msg->message, "/cmdlist"))
+			{
+				game.send_chat_target(client_id, "---Command List---");
+				game.send_chat_target(client_id, "\"/info\" information about the mod");
+				game.send_chat_target(client_id, "\"/mods\" shows the used mods");
+				game.send_chat_target(client_id, "\"/rank\" shows your rank");
+				game.send_chat_target(client_id, "\"/rank NAME\" shows the rank of a specific player");
+				game.send_chat_target(client_id, "\"/top5 X\" shows the top 5");
+			}
+			else if(!strncmp(msg->message, "/", 1))
+			{
+				game.send_chat_target(client_id, "Wrong command.");
+				game.send_chat_target(client_id, "Say \"/cmdlist\" for list of command available.");
+			}
+			else
+				game.send_chat(client_id, team, msg->message);
+		}
 	}
 	else if(msgtype == NETMSGTYPE_CL_CALLVOTE)
 	{
@@ -257,7 +346,7 @@
 				return;
 			}
 			
-			str_format(chatmsg, sizeof(chatmsg), "Vote called to kick '%s'", server_clientname(kick_id));
+			str_format(chatmsg, sizeof(chatmsg), "%s called for vote to kick '%s'", server_clientname(client_id), server_clientname(kick_id));
 			str_format(desc, sizeof(desc), "Kick '%s'", server_clientname(kick_id));
 			str_format(cmd, sizeof(cmd), "kick %d", kick_id);
 			if (!config.sv_vote_kick_bantime)
@@ -397,6 +486,8 @@
 		p->last_kill = time_get();
 		p->kill_character(WEAPON_SELF);
 		p->respawn_tick = server_tick()+server_tickspeed()*3;
+		if(game.controller->is_race())
+			p->respawn_tick = server_tick();
 	}
 }
 
@@ -470,6 +561,55 @@
 	(void) game.controller->check_team_balance();
 }
 
+static void con_kill_pl(void *result, void *user_data)
+{
+	int cid = clamp(console_arg_int(result, 0), 0, (int)MAX_CLIENTS-1);
+	if(!game.players[cid] || !game.controller->is_race())
+		return;
+	
+	game.players[cid]->kill_character(WEAPON_GAME);
+	char buf[512];
+	str_format(buf, sizeof(buf), "%s Killed by admin", server_clientname(cid));
+	game.send_chat(-1, GAMECONTEXT::CHAT_ALL, buf);
+}
+
+static void con_teleport(void *result, void *user_data)
+{
+	int cid1 = clamp(console_arg_int(result, 0), 0, (int)MAX_CLIENTS-1);
+	int cid2 = clamp(console_arg_int(result, 1), 0, (int)MAX_CLIENTS-1);
+	if(game.players[cid1] && game.players[cid2] && game.controller->is_race())
+	{
+		CHARACTER* chr = game.players[cid1]->get_character();
+		if(chr)
+		{
+			chr->core.pos = game.players[cid2]->view_pos;
+			chr->race_state = RACE_FINISHED;
+		}
+	}
+}
+
+static void con_teleport_to(void *result, void *user_data)
+{
+	int cid = clamp(console_arg_int(result, 0), 0, (int)MAX_CLIENTS-1);
+	if(game.players[cid] && game.controller->is_race())
+	{
+		CHARACTER* chr = game.players[cid]->get_character();
+		if(chr)
+		{
+			chr->core.pos.x = console_arg_int(result, 1);
+			chr->core.pos.y = console_arg_int(result, 2);
+			chr->race_state = RACE_FINISHED;
+		}
+	}
+}
+
+static void con_get_pos(void *result, void *user_data)
+{
+	int cid = clamp(console_arg_int(result, 0), 0, (int)MAX_CLIENTS-1);
+	if(game.players[cid])
+		dbg_msg("Tele", "%s pos: %d @ %d", server_clientname(cid), (int)game.players[cid]->view_pos.x, (int)game.players[cid]->view_pos.y);
+}
+
 static void con_addvote(void *result, void *user_data)
 {
 	int len = strlen(console_arg_string(result, 0));
@@ -513,6 +653,11 @@
 
 	MACRO_REGISTER_COMMAND("addvote", "r", CFGFLAG_SERVER, con_addvote, 0, "");
 	MACRO_REGISTER_COMMAND("vote", "r", CFGFLAG_SERVER, con_vote, 0, "");
+	
+	MACRO_REGISTER_COMMAND("teleport", "ii", CFGFLAG_SERVER, con_teleport, 0, "");
+	MACRO_REGISTER_COMMAND("teleport_to", "iii", CFGFLAG_SERVER, con_teleport_to, 0, "");
+	MACRO_REGISTER_COMMAND("get_pos", "i", CFGFLAG_SERVER, con_get_pos, 0, "");
+	MACRO_REGISTER_COMMAND("kill_pl", "i", CFGFLAG_SERVER, con_kill_pl, 0, "");
 }
 
 void mods_init()
@@ -537,6 +682,8 @@
 		game.controller = new GAMECONTROLLER_CTF;
 	else if(strcmp(config.sv_gametype, "tdm") == 0)
 		game.controller = new GAMECONTROLLER_TDM;
+	else if(strcmp(config.sv_gametype, "race") == 0)
+		game.controller = new GAMECONTROLLER_RACE;
 	else
 		game.controller = new GAMECONTROLLER_DM;
 
Index: src/game/server/player.cpp
===================================================================
--- src/game/server/player.cpp	(Revision 2005)
+++ src/game/server/player.cpp	(Arbeitskopie)
@@ -156,7 +156,9 @@
 	
 	kill_character(WEAPON_GAME);
 	team = new_team;
-	score = 0;
+	//race
+	if(!game.controller->is_race())
+		score = 0;
 	dbg_msg("game", "team_join player='%d:%s' team=%d", client_id, server_clientname(client_id), team);
 	
 	game.controller->on_player_info_change(game.players[client_id]);
@@ -173,7 +175,7 @@
 	ENTITY *ents[2] = {0};
 	int num_ents = game.world.find_entities(spawnpos, 64, ents, 2, NETOBJTYPE_CHARACTER);
 	
-	if(num_ents == 0)
+	if(num_ents == 0 || game.controller->is_race())
 	{
 		spawning = false;
 		character = new(client_id) CHARACTER();
Index: src/game/server/score.cpp
===================================================================
--- src/game/server/score.cpp	(Revision 0)
+++ src/game/server/score.cpp	(Revision 0)
@@ -0,0 +1,215 @@
+/* copyright (c) 2008 rajh and gregwar. Score stuff */
+
+#include "score.hpp"
+#include <engine/e_config.h>
+#include <sstream>
+#include <fstream>
+#include <list>
+#include <string>
+#include <string.h>
+#include "gamecontext.hpp"
+
+static LOCK score_lock = 0;
+
+PLAYER_SCORE::PLAYER_SCORE(const char *name, float score, const char *ip, float cp_time[42])
+{
+	str_copy(this->name, name, sizeof(this->name));
+	this->score = score;
+	str_copy(this->ip, ip, sizeof(this->ip));
+	for(int i = 0; i < 42; i++)
+		this->cp_time[i] = cp_time[i];
+}
+
+std::list<PLAYER_SCORE> top;
+
+SCORE::SCORE()
+{
+	if(score_lock == 0)
+		score_lock = lock_create();
+	load();
+}
+
+std::string save_file()
+{
+	std::ostringstream oss;
+	oss << config.sv_map << "_record.dtb";
+	return oss.str();
+}
+
+static void save_score_thread(void *)
+{
+	lock_wait(score_lock);
+	std::fstream f;
+	f.open(save_file().c_str(), std::ios::out);
+	if(!f.fail())
+	{
+		int t = 0;
+		for(std::list<PLAYER_SCORE>::iterator i = top.begin(); i != top.end(); i++)
+		{
+			f << i->name << std::endl << i->score << std::endl  << i->ip << std::endl;
+			if(config.sv_checkpoint_save)
+			{
+				for(int c = 0; c < 25; c++)
+					f << i->cp_time[c+17] << " ";
+				f << std::endl;
+			}
+			t++;
+			if(t%50 == 0)
+				thread_sleep(1);
+		}
+	}
+	f.close();
+	lock_release(score_lock);
+}
+
+void SCORE::save()
+{
+	void *save_thread = thread_create(save_score_thread, 0);
+#if defined(CONF_FAMILY_UNIX)
+	pthread_detach((pthread_t)save_thread);
+#endif
+}
+
+void SCORE::load()
+{
+	lock_wait(score_lock);
+	std::fstream f;
+	f.open(save_file().c_str(), std::ios::in);
+	top.clear();
+	while (!f.eof() && !f.fail())
+	{
+		std::string tmpname, tmpscore, tmpip, tmpcpline;
+		std::getline(f, tmpname);
+		if(!f.eof() && tmpname != "")
+		{
+			std::getline(f, tmpscore);
+			std::getline(f, tmpip);
+			float tmpcptime[42] = {0};
+			if(config.sv_checkpoint_save)
+			{
+				std::getline(f, tmpcpline);
+				char *time = strtok((char*)tmpcpline.c_str(), " ");
+				int i = 0;
+				while(time != NULL && i < 25)
+				{
+					tmpcptime[i+17] = atof(time);
+					time = strtok(NULL, " ");
+					i++;
+				}
+			}
+			top.push_back(*new PLAYER_SCORE(tmpname.c_str(), atof(tmpscore.c_str()), tmpip.c_str(), tmpcptime));
+		}
+	}
+	f.close();
+	lock_release(score_lock);
+}
+
+PLAYER_SCORE *SCORE::search_score(int id, bool score_ip, int *position)
+{
+	char ip[16];
+	server_getip(id, ip);
+	
+	int pos = 1;
+	for(std::list<PLAYER_SCORE>::iterator i = top.begin(); i != top.end(); i++)
+	{
+		if(!strcmp(i->ip, ip) && config.sv_score_ip && score_ip)
+		{
+			if(position)
+				*position = pos;
+			return & (*i);
+		}
+		pos++;
+	}
+	
+	return search_name(server_clientname(id), position, 0);
+}
+
+PLAYER_SCORE *SCORE::search_name(const char *name, int *position, bool nocase)
+{
+	PLAYER_SCORE *player = 0;
+	int pos = 1;
+	int found = 0;
+	for (std::list<PLAYER_SCORE>::iterator i = top.begin(); i != top.end(); i++)
+	{
+		if(str_find_nocase(i->name, name))
+		{
+			if(position)
+				*position = pos;
+			if(nocase)
+			{
+				found++;
+				player = & (*i);
+			}
+			if(!strcmp(i->name, name))
+				return & (*i);
+		}
+		pos++;
+	}
+	if(found > 1)
+	{
+		if(position)
+			*position = -1;
+		return 0;
+	}
+	return player;
+}
+
+void SCORE::parsePlayer(int id, float score, float cp_time[42])
+{
+	const char *name = server_clientname(id);
+	char ip[16];
+	server_getip(id, ip);
+	
+	lock_wait(score_lock);
+	PLAYER_SCORE *player = search_score(id, 1, 0);
+	if(player)
+	{
+		for(int c = 0; c < 42; c++)
+		{
+			if(player->cp_time[c] == 0 || player->score > score)
+				player->cp_time[c] = cp_time[c];
+		}
+		if(player->score > score)
+		{
+			player->score = score;
+			str_copy(player->name, name, sizeof(player->name));
+		}
+	}
+	else
+		top.push_back(*new PLAYER_SCORE(name, score, ip, cp_time));
+	
+	top.sort();
+	lock_release(score_lock);
+	save();
+}
+
+void SCORE::initPlayer(int id)
+{
+	char ip[16];
+	server_getip(id, ip);
+	PLAYER_SCORE *player = search_score(id, 0, 0);
+	if(player)
+	{
+		lock_wait(score_lock);
+		str_copy(player->ip, ip, sizeof(player->ip));
+		lock_release(score_lock);
+		save();
+	}
+}
+
+void SCORE::top5_draw(int id, int debut)
+{
+	int pos = 1;
+	char buf[512];
+	game.send_chat_target(id, "----------- Top 5 -----------");
+	for (std::list<PLAYER_SCORE>::iterator i = top.begin(); i != top.end() && pos <= 5+debut; i++)
+	{
+		if(pos >= debut)
+		{
+			str_format(buf, sizeof(buf), "%d. %s Time: %d minute(s) %5.3f second(s)", pos, i->name, (int) i->score/60, i->score-((int)i->score/60*60));
+			game.send_chat_target(id, buf);
+		}
+		pos++;
+	}
+	game.send_chat_target(id, "-----------------------------");
+}
Index: src/game/server/score.hpp
===================================================================
--- src/game/server/score.hpp	(Revision 0)
+++ src/game/server/score.hpp	(Revision 0)
@@ -0,0 +1,36 @@
+/* copyright (c) 2008 rajh and gregwar. Score stuff */
+
+#ifndef SCORE_H_RACE
+#define SCORE_H_RACE
+#include <engine/e_server_interface.h>
+
+class PLAYER_SCORE
+{
+public:
+	char name[MAX_NAME_LENGTH];
+	float score;
+	char ip[16];
+	float cp_time[42];
+	
+	PLAYER_SCORE(const char *name, float score, const char *ip, float cp_time[42]);
+	
+	bool operator==(const PLAYER_SCORE& other) { return (this->score == other.score); }
+	bool operator<(const PLAYER_SCORE& other) { return (this->score < other.score); }
+};
+
+class SCORE
+{
+public:
+	SCORE();
+	
+	void save();
+	void load();
+	PLAYER_SCORE *search_score(int id, bool score_ip, int *position);
+	PLAYER_SCORE *search_name(const char *name, int *position, bool match_case);
+	void parsePlayer(int id, float score, float cp_time[42]);
+	void initPlayer(int id);
+	void top5_draw(int id, int debut);
+};
+
+#endif
+
Index: src/game/variables.hpp
===================================================================
--- src/game/variables.hpp	(Revision 2005)
+++ src/game/variables.hpp	(Arbeitskopie)
@@ -72,3 +72,21 @@
 
 MACRO_CONFIG_INT(dbg_focus, 0, 0, 1, CFGFLAG_CLIENT, "")
 MACRO_CONFIG_INT(dbg_tuning, 0, 0, 1, CFGFLAG_CLIENT, "")
+
+MACRO_CONFIG_INT(sv_reserved_slots, 0, 0, 12, CFGFLAG_SERVER, "")
+MACRO_CONFIG_STR(sv_reserved_slots_pass, 32, "", CFGFLAG_SERVER, "")
+
+/* race */
+MACRO_CONFIG_INT(sv_regen, 0, 0, 0, CFGFLAG_SERVER, "Set regeneration")
+MACRO_CONFIG_INT(sv_strip, 0, 0, 1, CFGFLAG_SERVER, "Enable or disable keeping weapon after teleporting")
+MACRO_CONFIG_INT(sv_infinite_ammo, 0, 0, 1, CFGFLAG_SERVER, "Enable or disable infinite ammo")
+MACRO_CONFIG_INT(sv_teleport, 0, 0, 1, CFGFLAG_SERVER, "Enable or disable teleportation")
+MACRO_CONFIG_INT(sv_teleport_grenade, 0, 0, 1, CFGFLAG_SERVER, "Enable or disable teleport of grenade")
+MACRO_CONFIG_INT(sv_teleport_kill, 0, 0, 1, CFGFLAG_SERVER, "Teleporting one someone kills him")
+MACRO_CONFIG_INT(sv_rocket_jump_damage, 1, 0, 1, CFGFLAG_SERVER, "Enable or disable rocket jump damage")
+MACRO_CONFIG_INT(sv_pickup_respawn, 1, 0, 10, CFGFLAG_SERVER, "Time before a pickup respawn")
+MACRO_CONFIG_INT(sv_speedup_mult, 10, 1, 100, CFGFLAG_SERVER, "Boost power by multiplication")
+MACRO_CONFIG_INT(sv_speedup_add, 0, -100, 100, CFGFLAG_SERVER, "Boost power")
+MACRO_CONFIG_INT(sv_jumper_add, 0, -100, 100, CFGFLAG_SERVER, "Jumper power")
+MACRO_CONFIG_INT(sv_score_ip, 1, 0, 1, CFGFLAG_SERVER, "")
+MACRO_CONFIG_INT(sv_checkpoint_save, 0, 0, 1, CFGFLAG_SERVER, "")
Index: src/game/version.hpp
===================================================================
--- src/game/version.hpp	(Revision 2005)
+++ src/game/version.hpp	(Arbeitskopie)
@@ -2,3 +2,5 @@
 #include "generated/nethash.c"
 #define GAME_VERSION "0.5.2"
 #define GAME_NETVERSION "0.5 " GAME_NETVERSION_HASH
+
+#define RACE_VERSION "2.3"
