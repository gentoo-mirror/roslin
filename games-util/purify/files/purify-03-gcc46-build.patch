diff --git a/nall/Makefile b/nall/Makefile
index 9929d10..4e5ffeb 100755
--- a/nall/Makefile
+++ b/nall/Makefile
@@ -45,7 +45,7 @@ ifeq ($(compiler),)
 endif
 
 c := $(compiler) -std=gnu99
-cpp := $(subst cc,++,$(compiler)) -std=gnu++11
+cpp := $(subst cc,++,$(compiler)) -std=gnu++0x
 
 ifeq ($(arch),x86)
   c := $(c) -m32
diff --git a/nall/property.hpp b/nall/property.hpp
index 1ddb5c9..665afca 100755
--- a/nall/property.hpp
+++ b/nall/property.hpp
@@ -5,6 +5,12 @@
 //example: property<owner>::readonly<type> implies that only owner has full
 //access to type; and all other code has readonly access.
 //
+//this code relies on extended friend semantics from C++0x to work, as it
+//declares a friend class via a template paramter. it also exploits a bug in
+//G++ 4.x to work even in C++98 mode.
+//
+//if compiling elsewhere, simply remove the friend class and private semantics
+
 //property can be used either of two ways:
 //struct foo {
 //  property<foo>::readonly<bool> x;
@@ -44,6 +50,8 @@
 
 namespace nall {
   template<typename C> struct property {
+    template<typename T> struct traits { typedef T type; };
+
     template<typename T> struct readonly {
       const T* operator->() const { return &value; }
       const T& operator()() const { return value; }
@@ -53,7 +61,7 @@ namespace nall {
       operator T&() { return value; }
       const T& operator=(const T& value_) { return value = value_; }
       T value;
-      friend C;
+      friend class traits<C>::type;
     };
 
     template<typename T> struct writeonly {
@@ -65,7 +73,7 @@ namespace nall {
       T* operator->() { return &value; }
       operator T&() { return value; }
       T value;
-      friend C;
+      friend class traits<C>::type;
     };
 
     template<typename T> struct readwrite {
